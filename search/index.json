[{"content":"前言 最近应公司项目要求，入坑Ionic，查了很多资料之后感觉还是使用TypeScript来写比较好，因本人本身的C++功底，TypeScript正好是类似面向对象形式的，这样接受新语言环境也比较快。\nTypeScript简介 资料显示，TypeScript之父与C#之父是同一人，所以用法与面向对象应该有相似之处，不过本人对C#不熟，此不做评论。\nTypeScript类似C++，需要编译为js来执行，也依然可以打断点来调试ts文件。而且TypeScript还有语法检查、变量类型等配置，实在是能提高js的安全性，因此我选择TypeScript来作为主语言。\n环境搭建 初始化项目 既然最终是编译成js，环境就是Node.JS了。配置好node与npm后创建一个Project目录:\n1 2 3 mkdir localtest cd localtest npm init 初始化项目会生成package.json文件，此文件为项目依赖库的跟踪文件，当你将项目分享给其他人时，无需全部分享，只需分享项目代码与此文件，对方即可使用npm install来自己创建项目依赖环境\npackage.json 样例:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 cat package.json { \u0026#34;name\u0026#34;: \u0026#34;localtest\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;This is a test.\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;index.js\u0026#34;, \u0026#34;dependencies\u0026#34;: {}, \u0026#34;devDependencies\u0026#34;: {}, \u0026#34;scripts\u0026#34;: { \u0026#34;test\u0026#34;: \u0026#34;echo \\\u0026#34;Error: no test specified\\\u0026#34; \u0026amp;\u0026amp; exit 1\u0026#34; }, \u0026#34;author\u0026#34;: \u0026#34;sohunjug\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;ISC\u0026#34; } 依赖库安装 下一步开始安装typescript、express、gulp等依赖库。\n1 2 3 npm install -g typescript npm install -g typings npm install -g tslint 国内可能npm速度不是很给力，可以使用阿里出品的cnpm:\n1 npm install -g cnpm --registry=https://registry.npm.taobao.org 之后上边的安装就可以使用新的cnpm，速度提升很大哦:\n1 2 3 cnpm install -g typescript cnpm install -g typings cnpm install -g tslint 这些常用的可以安装为全局及使用-g，也可以在项目中安装取消-g，加上\u0026ndash;save\n1 2 3 cnpm install --save typescript cnpm install --save typings cnpm install --save tslint 下面开始安装express等依赖库:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 cnpm install --save express cnpm install --save body-parser cnpm install --save jade cnpm install --save cookie-parser cnpm install --save morgan cnpm install --save gulp cnpm install --save gulp-tsc cnpm install --save run-sequence cnpm install --save gulp-util cnpm install --save gulp-clean cnpm install --save tiny-lr cnpm install --save gulp-live-server cnpm install --save gulp-tslint cnpm install --save debug 此时package.json变为:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 cat package.json { \u0026#34;name\u0026#34;: \u0026#34;localtest\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;This is a test.\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;index.js\u0026#34;, \u0026#34;dependencies\u0026#34;: { \u0026#34;body-parser\u0026#34;: \u0026#34;^1.15.2\u0026#34;, \u0026#34;cookie-parser\u0026#34;: \u0026#34;^1.4.3\u0026#34;, \u0026#34;debug\u0026#34;: \u0026#34;^2.2.0\u0026#34;, \u0026#34;express\u0026#34;: \u0026#34;^4.14.0\u0026#34;, \u0026#34;gulp\u0026#34;: \u0026#34;^3.9.1\u0026#34;, \u0026#34;gulp-clean\u0026#34;: \u0026#34;^0.3.2\u0026#34;, \u0026#34;gulp-live-server\u0026#34;: \u0026#34;^0.0.30\u0026#34;, \u0026#34;gulp-tsc\u0026#34;: \u0026#34;^1.2.3\u0026#34;, \u0026#34;gulp-tslint\u0026#34;: \u0026#34;^6.1.1\u0026#34;, \u0026#34;gulp-util\u0026#34;: \u0026#34;^3.0.7\u0026#34;, \u0026#34;jade\u0026#34;: \u0026#34;^1.11.0\u0026#34;, \u0026#34;morgan\u0026#34;: \u0026#34;^1.7.0\u0026#34;, \u0026#34;run-sequence\u0026#34;: \u0026#34;^1.2.2\u0026#34;, \u0026#34;tiny-lr\u0026#34;: \u0026#34;^0.2.1\u0026#34; }, \u0026#34;devDependencies\u0026#34;: {}, \u0026#34;scripts\u0026#34;: { \u0026#34;test\u0026#34;: \u0026#34;echo \\\u0026#34;Error: no test specified\\\u0026#34; \u0026amp;\u0026amp; exit 1\u0026#34; }, \u0026#34;author\u0026#34;: \u0026#34;sohunjug\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;ISC\u0026#34; } TypeScript中依赖安装 本人使用typings，据网上资料显示，tsd已经过时了，所以也木有研究，此处不做评论。\n此处typings，我是使用-g安装的全局:\n1 2 3 4 5 6 7 8 9 typings install --global --save dt~express typings install --global --save dt~node typings install --global --save dt~serve-static typings install --global --save dt~express-serve-static-core typings install --global --save dt~mime typings install --global --save dt~body-parser typings install --global --save dt~debug typings install --global --save dt~cookie-parser typings install --global --save dt~morgan 使用\u0026ndash;save安装本地则使用:\n1 2 3 4 5 6 7 8 9 node_modules/.bin/typings install --global --save dt~express node_modules/.bin/typings install --global --save dt~node node_modules/.bin/typings install --global --save dt~serve-static node_modules/.bin/typings install --global --save dt~express-serve-static-core node_modules/.bin/typings install --global --save dt~mime node_modules/.bin/typings install --global --save dt~body-parser node_modules/.bin/typings install --global --save dt~debug node_modules/.bin/typings install --global --save dt~cookie-parser node_modules/.bin/typings install --global --save dt~morgan gulp配置 同样看到网上评论，grunt为基于json配置来管理自动化部署，而gulp基于代码形式，更倾向于程序员使用，而且可以自己制作部署细节。\n基于网上找到的配置，使用了一下发现对于express的app形式的热更新不支持，所以又找了些资料，终于自己配置出来了，现分享下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 var gulp = require(\u0026#39;gulp\u0026#39;); var tsc = require(\u0026#39;gulp-tsc\u0026#39;); var seq = require(\u0026#39;run-sequence\u0026#39;); var del = require(\u0026#39;gulp-clean\u0026#39;); var gls = require(\u0026#39;gulp-live-server\u0026#39;); var chalk = require(\u0026#39;chalk\u0026#39;); var gutil = require(\u0026#39;gulp-util\u0026#39;); var tslint = require(\u0026#39;gulp-tslint\u0026#39;); var paths = { ts: { src: [ \u0026#39;app/**/*.ts\u0026#39; ], dest: \u0026#39;build\u0026#39; } } gulp.task(\u0026#39;serve\u0026#39;, () =\u0026gt; { seq(\u0026#39;clean\u0026#39;, \u0026#39;build\u0026#39;, \u0026#39;watch\u0026#39;); }) gulp.task(\u0026#39;watch\u0026#39;, () =\u0026gt; { var server = gls.new(\u0026#39;build/www.js\u0026#39;); server.start(); gulp.watch([\u0026#39;app/**/*.ts\u0026#39;], () =\u0026gt; seq(\u0026#39;tslint\u0026#39;, \u0026#39;clean\u0026#39;, \u0026#39;build\u0026#39;)); gulp.watch([\u0026#39;build/**/*.js\u0026#39;, \u0026#39;build/**/*.css\u0026#39;, \u0026#39;build/**/*.html\u0026#39;], file =\u0026gt; server.notify.apply(server, [file]) ); gulp.watch(\u0026#39;build/www.js\u0026#39;, () =\u0026gt; { setTimeout(() =\u0026gt; gutil.log(\u0026#39;Restart Succeed!\u0026#39;), 500); server.start.bind(server)() }); }); gulp.task(\u0026#39;build\u0026#39;, () =\u0026gt; { return gulp.src(paths.ts.src) .pipe(tslint({ formatter: \u0026#34;verbose\u0026#34; })) .pipe(tsc({ module: \u0026#34;CommonJS\u0026#34;, sourcemap: true, emitError: false })) .pipe(gulp.dest(paths.ts.dest)); }); gulp.task(\u0026#39;clean\u0026#39;, () =\u0026gt; { del(paths.ts.dest); }); gulp.task(\u0026#39;rebuild\u0026#39;, file =\u0026gt; { seq(\u0026#39;clean\u0026#39;, \u0026#39;build\u0026#39;); }); gulp.task(\u0026#34;tslint\u0026#34;, () =\u0026gt; { return gulp.src(paths.ts.src) .pipe(tslint({ formatter: \u0026#34;verbose\u0026#34; })) .pipe(tslint.report()); }); gulp.task(\u0026#39;default\u0026#39;, [\u0026#39;rebuild\u0026#39;]); 此配置可以在当前目录中使用gulp来启动了，默认gulp执行default任务(即重新编译)，还可以手动自己执行不同的task任务，其中gulp serve是自动热更新部署。\n效果为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 $ gulp serve [15:27:30] Using gulpfile xxxx/localtest/gulpfile.js [15:27:30] Starting \u0026#39;serve\u0026#39;... [15:27:30] Starting \u0026#39;clean\u0026#39;... [15:27:30] Finished \u0026#39;clean\u0026#39; after 1.36 ms [15:27:30] Starting \u0026#39;build\u0026#39;... [15:27:30] Finished \u0026#39;serve\u0026#39; after 15 ms [15:27:30] Compiling TypeScript files using tsc version 1.8.10 [15:27:32] Finished \u0026#39;build\u0026#39; after 2.6 s [15:27:32] Starting \u0026#39;watch\u0026#39;... [15:27:32] Finished \u0026#39;watch\u0026#39; after 57 ms livereload[tiny-lr] listening on 35729 ... [15:27:38] Starting \u0026#39;tslint\u0026#39;... [15:27:38] Finished \u0026#39;tslint\u0026#39; after 213 ms [15:27:38] Starting \u0026#39;clean\u0026#39;... [15:27:38] Finished \u0026#39;clean\u0026#39; after 266 μs [15:27:38] Starting \u0026#39;build\u0026#39;... [15:27:38] Compiling TypeScript files using tsc version 1.8.10 [15:27:40] Finished \u0026#39;build\u0026#39; after 2.39 s [15:27:41] Restart Succeed! 项目样例代码已更新GitHub(TypeScript-RESTful-sample)\n代码中RESTFul样例我开发了一个简单的路由小框架。欢迎star。\n参考链接： http://brianflove.com/2016/03/29/typescript-express-node-js/\nhttps://www.npmjs.com/package/gulp-live-server\n","date":"2016-09-13T15:58:43+08:00","permalink":"https://sohunjug.com/2016/09/13/typescript-node.js--gulp--express-%E5%86%99restful-api-%E5%81%9A%E5%90%8E%E7%AB%AF/","title":"TypeScript: (Node.JS + gulp + express) 写RESTful API 做后端"},{"content":"更新 问题原因可能为 macOS 10.12 beta 系统问题，新更新为 10.12 beta 6 问题解决。\n目前版本已更新为 1.4.3，支持多窗口。\n起因 最近工作发现有时候需要测试发送 TCP 包，而目前 Mac 上又没有找到功能很好的软件，所以就自己开发了一个简单而实用的工具。PacketSender 因后来实用 ObjC 重写了的原因，所以开源旧版本的 Swift 版本吧。GitLab、GitHub\n所使用库 两个版本都使用的CocoaAsyncSocket开源库来实现 socket 连接。 在 objc 或 swift 中，主界面是在主线程中执行，所以相关 socket 操作等，尽量需要效率且非阻塞，让等待函数在后台线程执行，这个库正好满足。\n版本 Version 1.0 满足单一发送功能 Version 1.2 增加了发送历史记录功能 增加了消息背景 Version 1.3 增加了行数 修改了 Server 状态显示 增加了发收包数量复制 在此版本之前，一直未发现之前版本在 Mac OS X 10.11.6 版本，根本无法使用，NSTextView 无法选中，无法输入，也无法显示。 期初我以为是 Swift 在 macOS 10.12 beta 4 版本使用 Xcode 7.3.1 编译，造成不兼容问题，所以使用了 ObjC 重写了 Version 1.2.2。 但是结果显示问题依旧。虽然现在更新了 1.3 版本。但是此版本是使用朋友的机器，在 Mac OS X 10.11.6 环境下编译。\n待解决问题 希望以后如果有某位朋友找到解决办法，能沟通下，谢谢。\n欢迎关于 macOS 开发的朋友，来跟我一起交流技术。\n","date":"2016-08-18T22:33:12+08:00","permalink":"https://sohunjug.com/2016/08/18/packetsender-%E5%8F%91%E9%80%81%E6%8E%A5%E6%94%B6socket-macos-app/","title":"PacketSender 发送接收socket macOS App"},{"content":" 闲来无事，正好更新下以前写的脚本，自动登录ssh或telnet。 而且也方便记录密码。Git-oschina、GitHub\n使用connect.sh自动连接ssh或者telnet 其中配置文件conn.profile为json格式\n配置样例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 { \u0026#34;test1\u0026#34;: { \u0026#34;host\u0026#34;: \u0026#34;192.168.0.1\u0026#34;, \u0026#34;port\u0026#34;: 22, \u0026#34;user\u0026#34;: \u0026#34;root\u0026#34;, \u0026#34;pass\u0026#34;: \u0026#34;123456\u0026#34;, \u0026#34;connecttype\u0026#34;: \u0026#34;ssh\u0026#34;, \u0026#34;sshtype\u0026#34;: \u0026#34;pass\u0026#34;, \u0026#34;language\u0026#34;: \u0026#34;None\u0026#34; }, \u0026#34;test2\u0026#34;: { \u0026#34;host\u0026#34;: \u0026#34;192.168.0.1\u0026#34;, \u0026#34;port\u0026#34;: 22, \u0026#34;user\u0026#34;: \u0026#34;root\u0026#34;, \u0026#34;pass\u0026#34;: \u0026#34;123456\u0026#34;, \u0026#34;connecttype\u0026#34;: \u0026#34;ssh\u0026#34;, \u0026#34;sshtype\u0026#34;: \u0026#34;~/.ssh/test_rsa\u0026#34;, \u0026#34;language\u0026#34;: \u0026#34;en_US.UTF-8\u0026#34; }, \u0026#34;test3\u0026#34;: { \u0026#34;host\u0026#34;: \u0026#34;192.168.0.1\u0026#34;, \u0026#34;port\u0026#34;: 23, \u0026#34;user\u0026#34;: \u0026#34;root\u0026#34;, \u0026#34;pass\u0026#34;: \u0026#34;123456\u0026#34;, \u0026#34;connecttype\u0026#34;: \u0026#34;telnet\u0026#34;, \u0026#34;language\u0026#34;: \u0026#34;en_US.UTF-8\u0026#34; } } 可以自定义设置别名 echo \u0026lsquo;aliases=\u0026quot;$HOME/Documents/ssh/connect.sh\u0026quot;\u0026rsquo; \u0026raquo; ~/.bashrc\n之后执行 connect show test1\n1 2 3 4 5 6 7 /test1/host\t192.168.0.1 /test1/port\t22 /test1/user\troot /test1/pass\t123456 /test1/connecttype\tssh /test1/sshtype\tpass /test1/language\ten_US.UTF-8 connect test1\n1 2 Last login: Mon Aug 8 23:48:46 2016 from gateway [root@clusterA31 ~]# 附带脚本文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 #!/bin/sh [ -z \u0026#34;$CONNJSON\u0026#34; ] \u0026amp;\u0026amp; _BJSON=$HOME/Documents/ssh/json.sh || _BJSON=$CONNJSON [ -z \u0026#34;$CONNCFG\u0026#34; ] \u0026amp;\u0026amp; _C_CFG=$HOME/Documents/ssh/conn.profile || _C_CFG=$CONNCFG if [ ! -f $_C_CFG ]; then echo \u0026#34;not fount profile file $_C_CFG\u0026#34; exit 0 fi source $_BJSON function connect() { name=$1 config=`json \u0026lt; $_C_CFG | grep $name` row=`json \u0026lt; $_C_CFG | grep $name | wc -l` if [ $row -gt 7 ]; then echo \u0026#34;fount to many configs\\n$config\\n\u0026#34; exit 0 fi connhost=`json \u0026lt; $_C_CFG | grep $name | grep \u0026#34;host\u0026#34; | grep -v grep | awk \u0026#39;{print \\$3}\u0026#39;` if [ -z $connhost ]; then echo error: 没有那个IP exit 0 fi connport=`json \u0026lt; $_C_CFG | grep $name | grep \u0026#34;port\u0026#34; | grep -v grep | awk \u0026#39;{print \\$3}\u0026#39;` connuser=`json \u0026lt; $_C_CFG | grep $name | grep \u0026#34;user\u0026#34; | grep -v grep | awk \u0026#39;{print \\$3}\u0026#39;` connpass=`json \u0026lt; $_C_CFG | grep $name | grep \u0026#34;pass\u0026#34; | grep -v grep | awk \u0026#39;{print \\$3}\u0026#39;` connlang=`json \u0026lt; $_C_CFG | grep $name | grep \u0026#34;lang\u0026#34; | grep -v grep | awk \u0026#39;{print \\$3}\u0026#39;` conntype=`json \u0026lt; $_C_CFG | grep $name | grep \u0026#34;conn\u0026#34; | grep -v grep | awk \u0026#39;{print \\$3}\u0026#39;` conntssh=`json \u0026lt; $_C_CFG | grep $name | grep \u0026#34;ssht\u0026#34; | grep -v grep | awk \u0026#39;{print \\$3}\u0026#39;` [ -z \u0026#34;$connport\u0026#34; ] \u0026amp;\u0026amp; connport=22 [ -z \u0026#34;$connuser\u0026#34; ] \u0026amp;\u0026amp; connuser=\u0026#39;root\u0026#39; [ -z \u0026#34;$connpass\u0026#34; ] \u0026amp;\u0026amp; connpass=\u0026#39;123456\u0026#39; [ -z \u0026#34;$connlang\u0026#34; ] \u0026amp;\u0026amp; connlang=\u0026#39;None\u0026#39; [ -z \u0026#34;$conntype\u0026#34; ] \u0026amp;\u0026amp; conntype=\u0026#39;ssh\u0026#39; [ -z \u0026#34;$conntssh\u0026#34; ] \u0026amp;\u0026amp; conntssh=\u0026#39;pass\u0026#39; if [ \u0026#34;$connlang\u0026#34; != \u0026#34;None\u0026#34; ]; then locallang=$LANG locallcall=$LC_ALL export LANG=$connlang export LC_ALL=$connlang fi if [ \u0026#34;$conntype\u0026#34; == \u0026#34;ssh\u0026#34; ]; then connstr=\u0026#34;spawn ssh -p${connport} ${connuser}@${connhost} expect { \\\u0026#34;*(yes/no)*\\\u0026#34; { send \\\u0026#34;yes\\n\\\u0026#34;; exp_continue } -re \\\u0026#34;assword:|assw\\\u0026#34; { send \\\u0026#34;${connpass}\\n\\\u0026#34; } }\u0026#34; if [ \u0026#34;$conntssh\u0026#34; != \u0026#34;pass\u0026#34; ]; then connstr=\u0026#34;spawn ssh -p${connport} ${connuser}@${connhost} -i${conntssh} expect { \\\u0026#34;*(yes/no)*\\\u0026#34; { send \\\u0026#34;yes\\n\\\u0026#34; } -re \\\u0026#34;\u0026gt;|]|$|#\\\u0026#34; { send \\\u0026#34;\\n\\\u0026#34; } }\u0026#34; fi expect -c \u0026#34; set timeout 10000 stty -echo ${connstr} if { \\\u0026#34;${connlang}\\\u0026#34; != \\\u0026#34;None\\\u0026#34; } { expect { -re \\\u0026#34;\u0026gt;|]|$|#\\\u0026#34; { send \\\u0026#34;export LANG=${connlang} \u0026amp;\u0026amp; export LC_ALL=${connlang}\\n\\\u0026#34; } } } interact \u0026#34; elif [ \u0026#34;$conntype\u0026#34; == \u0026#34;telnet\u0026#34; ]; then echo $connlang expect -c \u0026#34; set timeout 10000 stty -echo spawn telnet ${connhost} ${connport} expect { \\\u0026#34;*(yes/no)*\\\u0026#34; { send \\\u0026#34;yes\\n\\\u0026#34;; exp_continue } \\\u0026#34;*ogin*\\\u0026#34; { send \\\u0026#34;${connuser}\\n\\\u0026#34;; exp_continue } -re \\\u0026#34;assword:|assw\\\u0026#34; { send \\\u0026#34;${connpass}\\n\\\u0026#34; } } if { \\\u0026#34;${connlang}\\\u0026#34; != \\\u0026#34;None\\\u0026#34; } { expect { -re \\\u0026#34;\u0026gt;|]|$|#\\\u0026#34; { send \\\u0026#34;export LANG=${connlang} \u0026amp;\u0026amp; export LC_ALL=${connlang}\\n\\\u0026#34; } } } interact \u0026#34; fi if [ \u0026#34;$connlang\u0026#34; != \u0026#34;None\u0026#34; ]; then locallang=$LANG locallcall=$LC_ALL export LANG=$locallang export LC_ALL=$locallcall fi } function showconn() { json \u0026lt; $_C_CFG | grep $1 | awk \u0026#39;{printf(\u0026#34;%-25s\\t%s\\n\u0026#34;, $1, $3)}\u0026#39; } case \u0026#34;$1\u0026#34; in show) showconn $2 ;; help) echo \u0026#34;$0 onename\\n$0 show onename\u0026#34; \u0026gt;\u0026amp;2 ;; *) connect $1 ;; esac exit 0 ","date":"2016-08-08T17:31:53+08:00","permalink":"https://sohunjug.com/2016/08/08/%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95ssh%E6%88%96telnet%E8%84%9A%E6%9C%AC/","title":"自动登录ssh或telnet脚本"},{"content":"Kafka是Linkin开源的消息中间件 Kafka的设计目标是： （1）以时间复杂度为O(1)的方式提供消息持久化能力，即使对TB级以上数据也能保证常数时间复杂度的访问性能。 （2）高吞吐率。即使在非常廉价的商用机器上也能做到单机支持每秒100K条以上消息的传输。 （3）支持Kafka Server间的消息分区，及分布式消费，同时保证每个Partition内的消息顺序传输。 （4）同时支持离线数据处理和实时数据处理。 （5）Scale out：支持在线水平扩展。\nRocketMQ是阿里开源的消息中间件 其最初也是基于Kafka发展而来。\n数据可靠性 RocketMQ支持异步实时刷盘，同步刷盘，同步Replication，异步Replication Kafka使用异步刷盘方式，异步Replication/同步Replication 性能对比 Kafka会在Producer端将多个小消息合并，批量发向Broker，所以在批量发送消息时有着大量的优势，在批量时，Kafka单机写入TPS约在百万条/秒，消息大小100个字节 RocketMQ单机写入TPS单实例约7万条/秒，RocketMQ在阿里使用在淘宝支付宝端，在处理异步消息需要保证消息到达，所以未实现api级别批量发送消息 单机支持的队列数 Kafka单机超过64个队列/分区，Load会发生明显的飙高现象，队列越多，load越高，发送消息响应时间变长。 RocketMQ单机支持最高5万个队列，Load不会发生明显变化 严格的消息顺序 Kafka支持消息顺序，但是一台Broker宕机后，就会产生消息乱序 RocketMQ支持严格的消息顺序，在顺序消息场景下，一台Broker宕机后，发送消息会失败，但是不会乱序 分布式事务消息 Kafka不支持分布式事务消息 阿里云MQ支持分布式事务消息，未来开源版本的RocketMQ也有计划支持分布式事务消息 消息查询 Kafka不支持消息查询 RocketMQ支持根据Message Id查询消息，也支持根据消息内容查询消息（发送消息时指定一个Message Key，任意字符串，例如指定为订单Id） 总结：消息查询对于定位消息丢失问题非常有帮助，例如某个订单处理失败，是消息没收到还是收到处理出错了。\n消息回溯 Kafka理论上可以按照Offset来回溯消息 RocketMQ支持按照时间来回溯消息，精度毫秒，例如从一天之前的某时某分某秒开始重新消费消息 总结：典型业务场景如consumer做订单分析，但是由于程序逻辑或者依赖的系统发生故障等原因，导致今天消费的消息全部无效，需要重新从昨天零点开始消费，那么以时间为起点的消息重放功能对于业务非常有帮助。\n消费并行度 Kafka的消费并行度依赖Topic配置的分区数，如分区数为10，那么最多10台机器来并行消费（每台机器只能开启一个线程），或者一台机器消费（10个线程并行消费）。即消费并行度和分区数一致。 RocketMQ消费并行度分两种情况 顺序消费方式并行度同Kafka完全一致 乱序方式并行度取决于Consumer的线程数，如Topic配置10个队列，10台机器消费，每台机器100个线程，那么并行度为1000。 Broker端消息过滤 Kafka不支持Broker端的消息过滤 RocketMQ支持两种Broker端消息过滤方式 根据Message Tag来过滤，相当于子topic概念 向服务器上传一段Java代码，可以对消息做任意形式的过滤，甚至可以做Message Body的过滤拆分。 单机系统可靠性 模拟进程退出 在消息收发过程中，利用Kill -9 命令使Broker进程终止，然后重新启动，得到可靠性数据如下：\n产品 刷盘策略 并发 tps 丢失 重复 Kafka 异步 3 600 不丢 不重复 Kafka 异步 30 10500 不丢 不重复 Kafka 异步 150 49200 不丢 重复7条 RocketMQ 异步 1 4066 不丢 不重复 RocketMQ 异步 3 10900 不丢 不重复 RocketMQ 异步 140 52428 不丢 不重复 在Broker进程被终止重启，Kafka和RMQ都能保证同步发送的消息不丢，因为进程退出后操作系统能确保将该进程遗留在内存的数据刷到磁盘上。实验中，Kafka出现了极少量的消息重复。再次可以确定此场景中，二者的可靠性都很高。\n模拟机器掉电 在消息收发过程中，直接拔掉Broker所在的宿主机电源，然后重启宿主机和Broker应用。因受到机房断电限制，我们在本场景测试中使用的是普通PC机器。得到可靠性数据如下：\n产品 刷盘策略 并发 tps 丢失 重复 Kafka 异步 5 2000 丢失3条 掉电前所有发送重新消费 Kafka 同步 5 300 不丢 重复3条 Kafka 同步 60 500 不丢 重复2w条 RocketMQ 异步 5 2500 丢失19条 不重复 RocketMQ 同步 5 800 不丢 掉电前所有发送重新消费 RocketMQ 同步 60 4000 不丢 掉电前所有发送重新消费 ###测试结论\n在Broker进程被Kill的场景， Kafka和RocketMQ都能在保证吞吐量的情况下，不丢消息，可靠性都比较高。 在宿主机掉电的场景，Kafka与RocketMQ均能做到不丢消息，此时Kafka的吞吐量会急剧下跌，几乎不可用。RocketMQ则仍能保持较高的吞吐量。 在单机可靠性方面，RocketMQ综合表现优于Kafka。 ","date":"2016-08-08T09:10:28+08:00","permalink":"https://sohunjug.com/2016/08/08/kafkarocketmq%E8%B0%83%E7%A0%94/","title":"Kafka、RocketMQ调研"},{"content":"无论是在网络上还是项目中，define的用法非常广泛，define是由预处理程序自动完成的，被成为宏定义。\n宏定义的作用范围仅限于当前文件(头文件除外，包含该头文件的源文件中都可使用)，一般define分为有参数和无参数两种。\n宏定义优点 (1) 方便程序的修改 使用简单宏定义可用宏代替一个在程序中经常使用的常量，这样在将该常量改变时，不用对整个程序进行修改，只修改宏定义的字符串即可，而且当常量比较长时， 我们可以用较短的有意义的标识符来写程序，这样更方便一些。我们所说的常量改变不是在程序运行期间改变，而是在编程期间的修改，举一个大家比较熟悉的例 子，圆周率π是在数学上常用的一个值，有时我们会用3.14来表示，有时也会用3.1415926等，这要看计算所需要的精度，如果我们编制的一个程序中 要多次使用它，那么需要确定一个数值，在本次运行中不改变，但也许后来发现程序所表现的精度有变化，需要改变它的值， 这就需要修改程序中所有的相关数值，这会给我们带来一定的不便，但如果使用宏定义，使用一个标识符来代替，则在修改时只修改宏定义即可，还可以减少输入 3.1415926这样长的数值多次的情况，我们可以如此定义 #define pi 3.1415926，既减少了输入又便于修改，何乐而不为呢？\n(2) 提高程序的运行效率 使用带参数的宏定义可完成函数调用的功能，又能减少系统开销，提高运行效率。正如C语言中所讲，函数的使用可以使程序更加模块化，便于组织，而且可重复利用，但在发生函数调用时，需要保留调用函数的现场，以便子函数执行结束后能返回继续执行，同样在子函数执行完后要恢复调用函数的现场，这都需要一定的时间，如果子函数执行的操作比较多，这种转换时间开销可以忽略，但如果子函数完成的功能比较少，甚至于只完成一点操作，如一个乘法语句的操作，则这部分转换开销就相对较大了，但使用带参数的宏定义就不会出现这个问 题，因为它是在预处理阶段即进行了宏展开，在执行时不需要转换，即在当地执行。宏定义可完成简单的操作，但复杂的操作还是要由函数调用来完成，而且宏定义所占用的目标代码空间相对较大。所以在使用时要依据具体情况来决定是否使用宏定义。\n宏定义的高级用法 在网上经常会看到一些人在宏定义中使用#号的例子\n(1)#单个#符号 单个#号是将当前参数变为字符串.如: {% codeblock lang:cpp %} #define TOSTR(X) #X {% endcodeblock %}\n(2)##双#符号 ##则用来连接前后两个参数，把它们变成一个字符串。如: {% codeblock lang:cpp %} #define STRCAT(X, Y) X##Y {% endcodeblock %}\n宏定义推荐写法\n在有些使用宏定义中会看到一些不一样的写法\n如: 1 2 3 4 5 6 7 #define _log_(_std, _format, ...) \\ do { \\ if (_std) \\ fprintf(_std, _format, ##__VA_ARGS__); \\ else \\ fprintf(stdout, _format, ##__VA_ARGS__); \\ } while(0) 有些人可能会有疑问为什么会要加一个do{}while(0)? 如果没有就会变成 1 2 3 4 5 #define _log_(_std, _format, ...) \\ if (_std) \\ fprintf(_std, _format, ##__VA_ARGS__); \\ else \\ fprintf(stdout, _format, ##__VA_ARGS__); 可能大家认为这个也可以，但是如果用法是这样呢? 1 2 3 if (…) _log_(…); else {} 展开就会变成 1 2 3 4 5 6 if (…) if (_std) fprintf(_std, _format,…); else\tfprintf(stdout, _format,…);; else {} 这样明显就会出现两个else了，语法错误，而有些人喜欢使用{}来替换do{}while(0)，\n让我们来想想一下展开会是什么结果呢？ 1 2 3 4 5 6 7 if (…) { if (_std) fprintf(_std, _format,…); else\tfprintf(stdout, _format,…); }; else {} 还是错误的else前面多了一个; 而do{}while(0)这种写法完全避免了类似的问题，另外, 现代编译器的优化模块能够足够聪明地注意到这个循环只会执行一次而将其优化掉. 综上所述, do { } while(0) 这个技术就是为了类似的宏可以在任何时候使用.\n宏定义的其他用途 而宏定义在项目中最好用的地方，就是完成跨平台支持，众所周知想linux，windows，mac，android等这些系统，在一些底层函数，编译参数等等都有不同，所以在项目中，完全可以使用#ifdefine 等宏定义来区分当前的系统环境，更可以细化到系统版本的分别，来完成针对化编译。这样完美的支持各种不同的环境。\n在linux，mac等环境可以查看一些系统已经定义好的环境变量来帮助我们区分，可以使用命令来查看 1 gcc -E -dM - \u0026lt; /dev/null 而windows可以登录msdn网站查看\nmsdn.microsoft.com\n","date":"2015-01-13T15:59:59+08:00","permalink":"https://sohunjug.com/2015/01/13/c-defined/","title":"C/C++中宏定义的用法"},{"content":"最近看到一句令人很有感觉的一句话，\u0026ldquo;The best is yet to come\u0026hellip;\u0026quot;，而我本人也很相信这句话。\n在这个一天天各种新技术出生的年代，大家都想什么技术都熟悉一点，不至于让人说out了，而本人又是处女座的，有那么点强迫症，非常喜欢使用自己的东西，所以索性就搭建了自己的git服务器。而Apple新出的OSX10.10 DP2又依然没有解决邮件客户端的问题，感觉又很不爽，正好看到过一个RainLoop的帖子，所以也把WebMail捅咕上了。\n搭建git服务器还是很简单的网上教程一大把，但我个人非常推荐这个huhamhire博客，里面的东西很杂，支持的gitweb也有好多，我搭建使用的是gitlist，后续打算再做一个密码验证功能，怎么说大家写的代码也不可能所有的都是开源不是，每个人都会有自己的隐私～\nWebMail相对来说就更简单了，网上找到的这个RainLoop实在太赞了，界面也很美观，但个人感觉还是应该做成用户名密码验证的，这样直接登录用户名密码就好了。现在每次都需要打邮箱全名加密码，很不爽～\n在此，以后个人开源的代码也就放在我自己的git上了，欢迎大家提供宝贵的意见哈～\n","date":"2014-06-24T20:15:57+08:00","permalink":"https://sohunjug.com/2014/06/24/%E4%B8%AA%E4%BA%BA%E6%90%AD%E5%BB%BAgit%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8Ewebmail%E6%9C%8D%E5%8A%A1%E5%99%A8/","title":"个人搭建git服务器与webmail服务器"},{"content":"从大学开始就折腾过wordpress，工作后也确实一直用着wordpress。步入社会发现大学里面的都算不上皮毛，不懂的东西实在太多了，如饥似渴的小小学习2年，终于换了份工作。\n当日子一步步的步上正轨，我的学习热情也慢慢回升了。记得是半年前吧，突然听说了octopress这个博客，只看介绍(A blogging framework for hackers.)就给人一种高大上的感觉哈。当时就想折腾下，可惜因为工作也忙，也想换工作，一直拖到了现在。\n新工作依然还是程序员，比较热爱这个职业吧。当做出一个作品时那种快感，没做过的人是体验不到的。平时上班因为刚入职，还不忙，正好下班就可以捅咕自己的东西了。可能因为处女座的原因，尤其喜欢把这些东西搞到自己的服务器上。没事看看vps，发现阿里云现在很便宜嘛，一个月才55，而且还可以申请试用5天，想到就办，申请个试用的，搭建环境测试，满意之后买vps。\n首先找到了部署vps的文章才大概明白了一些原理(汗，原来以为还需要架设git服务器)。部署Octopress到你的VPS\n其实网上很多博客写的都不是很明白，octopress根本没有那么复杂，只需要下载octopress，然后在自己的本机上配置，设置好ssh连接，就会同步到vps主机上，因为octopress是静态网页，只需要同步到服务器的网站目录就OK了。\n当时喜欢上octopress也是因为这个主题，我也找了好久，推荐给大家哈：链接地址\n详细的个性化配置我就不阐述了，网上资料也是可以找得到的。\n博客以后应该会经常更新了，欢迎大家前来指点哦！\n","date":"2014-04-19T16:20:27+08:00","permalink":"https://sohunjug.com/2014/04/19/%E7%BB%88%E4%BA%8E%E4%BB%8Ewordpress%E8%BD%AC%E7%A7%BB%E5%88%B0%E4%BA%86octopress/","title":"终于从wordpress转移到了octopress"},{"content":"最近和一些小伙伴一起合伙做了个小玩具，大家感觉还是满开心的，网站是parld音乐聚汇(推广下哈)。其中Mac客户端下载地址\n目前的Mac客户端功能还很简单，但是已经不影响使用了，制作过程中遇到了各种问题，发现在网上找Mac开发的相关资源实在是太难，所以我也同步写一点吧，分享给大家\n** 2016-08-11 **\n由于项目搁浅，现分享下当时的macOS端代码，objective-c代码Git-oschina，GitHub 代码技术都比较老了，欢迎指教。\n首先是音乐播放问题，对于第一次开发来说，我是在网上找了好多的demo来测试，所以选择了AudioStreamer，其次，需要做状态栏应用，所以找了一段代码 {% codeblock lang:objc %} NSMenu\t*menu;\n_statusItem = [[NSStatusBar systemStatusBar] statusItemWithLength:NSVariableStatusItemLength] ;\n[_statusItem setImage:[NSImage imageNamed:@\u0026ldquo;start\u0026rdquo;]]; [_statusItem setHighlightMode:YES]; [_statusItem setTitle:@\u0026quot; 音乐汇聚\u0026quot;];\nmenu = [[NSMenu alloc] initWithTitle:@\u0026ldquo;音乐汇聚\u0026rdquo;]; [menu addItemWithTitle:@\u0026ldquo;上一首\u0026rdquo; action:@selector(pre) keyEquivalent:@\u0026quot;\u0026quot;]; [menu addItemWithTitle:@\u0026ldquo;下一首\u0026rdquo; action:@selector(next) keyEquivalent:@\u0026quot;\u0026quot;]; [menu addItemWithTitle:@\u0026ldquo;更新音乐池\u0026rdquo; action:@selector(updateMusic) keyEquivalent:@\u0026quot;\u0026quot;]; [menu addItemWithTitle:@\u0026ldquo;关于\u0026rdquo; action:@selector(orderFrontStandardAboutPanel:) keyEquivalent:@\u0026quot;\u0026quot;]; [menu addItemWithTitle:@\u0026ldquo;退出\u0026rdquo; action:@selector(exit:) keyEquivalent:@\u0026quot;\u0026quot;]; [menu addObserver:view forKeyPath:@\u0026ldquo;123\u0026rdquo; options:NSKeyValueObservingOptionNew context:nil]; [_statusItem setMenu:menu]; {% endcodeblock %} 之后需要做的就是逻辑了，获取歌单，播放歌单。 后期的版本又添加了Mac笔记本的媒体播放键功能，同样是找了一段代码，封装好的，如果想了解原理也可自行下载。SPMediaKeyTap。 加入之后需要修改主程序 添加继承NSApplication的类 {% codeblock lang:objc %}\n(void)sendEvent:(NSEvent *)theEvent { // If event tap is not installed, handle events that reach the app instead BOOL shouldHandleMediaKeyEventLocally = ![SPMediaKeyTap usesGlobalMediaKeyTap];\nif(shouldHandleMediaKeyEventLocally \u0026amp;\u0026amp; [theEvent type] == NSSystemDefined \u0026amp;\u0026amp; [theEvent subtype] == SPSystemDefinedEventMediaKeys) { [(id)[self delegate] mediaKeyTap:nil receivedMediaKeyEvent:theEvent]; } [super sendEvent:theEvent]; } {% endcodeblock %} ${PRODUCT_NAME}-Info.plist文件中Principal class字段修改为重写的NSApplication\n并在主AppDelegate添加按键映射 {% codeblock lang:objc %} -(void)mediaKeyTap:(SPMediaKeyTap*)keyTap receivedMediaKeyEvent:(NSEvent*)event; { NSAssert([event type] == NSSystemDefined \u0026amp;\u0026amp; [event subtype] == SPSystemDefinedEventMediaKeys, @\u0026ldquo;Unexpected NSEvent in mediaKeyTap:receivedMediaKeyEvent:\u0026rdquo;); // here be dragons\u0026hellip; int keyCode = (([event data1] \u0026amp; 0xFFFF0000) \u0026raquo; 16); int keyFlags = ([event data1] \u0026amp; 0x0000FFFF); BOOL keyIsPressed = (((keyFlags \u0026amp; 0xFF00) \u0026raquo; 8)) == 0xA; int keyRepeat = (keyFlags \u0026amp; 0x1);\nif (keyIsPressed) { NSString *debugString; debugString = [NSString stringWithFormat:@\u0026quot;%@\u0026quot;, keyRepeat?@\u0026quot;, repeated.\u0026quot;:@\u0026quot;.\u0026quot;]; switch (keyCode) { case NX_KEYTYPE_PLAY: if (_isPlay) { [self pauseMusic]; } else{ [self playMusic]; } break; case NX_KEYTYPE_FAST: [self nextMusic]; break; case NX_KEYTYPE_REWIND: [self lastMusic]; break; default: break; // More cases defined in hidsystem/ev_keymap.h } } } {% endcodeblock %} 还要添加一个开机自启动的配置，同样可以使用LaunchAtLoginController，只需要将Check控件的value绑定到LaunchAtLoginController里面的launchAtLogin变量上即可\n以上就是第一个初级版本所用到的技术，比较简单，但是还是蛮实用的。 而从今天开始，打算重构做第二版本，支持Mac悬浮窗，拖拽文件上传，悬浮窗下拉主窗体，目前基本功能的技术难点已经基本完成，后续会继续发表博客。\n在如今Mac已经越来越多的情况下，Mac开发人员还是比较少的，希望大家都能一起来讨论讨论技术。共同提高\n","date":"2014-02-27T00:00:00+08:00","permalink":"https://sohunjug.com/2014/02/27/mac%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91-%E5%90%AF%E7%A8%8B/","title":"Mac应用开发-启程"},{"content":"在现实生活中，经常会用到线程池与队列的应用，所以写了一套可复利用接口。\n其中优先级队列的蓝本从stl中复制出来的，唯一修改的地方就是添加了一个写锁，当top时加锁，pop后才解锁，保证真正不重复取出或丢失数据。 因为使用模板来构造，所以目前只支持类成员函数的回调。 与线程池共同使用时，外部调用时，需要new一个任务类来添加到队列中，线程池主函数会调用完成后自动delete析构。\n此基于成员函数回调的线程池需要同优先级队列共同使用，原理是初始化一个初始为5个线程的线程池，并将自己的控制线程添加到最高优先级启动。控制线程的目的是当任务队列比较多时增加线程来增加效率，当任务队列少时减速线程来节约资源（目前未实现）\n连接池，需要同线程池与任务队列共同使用，同样为先初始化一定数量的连接，供多线程调度使用，其中包含一个控制线程，来控制连接池中的连接数量，当取出一个连接来用时，会给取出的连接加锁，所以使用完后需要调用返回函数，来归还使用完的连接。\n连接池的作用就是不必每次都创建连接使用完成后断开连接，而使用模板来构造扩展性更强，所以需要自己额外来写创建连接，与断开连接函数。\n需要注意连接池需要在线程之前析构。\n任务队列文件代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 /******************************************************************************* * Author : huwq * Email : sohunjug@hotmail.com * Last modified : 2013-11-18 10:46 * Filename : CTaskQueue.h * Description : * *****************************************************************************/ #ifndef __TASH_QUEUE_H__ #define __TASH_QUEUE_H__ #include \u0026lt;queue\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;pthread.h\u0026gt; #include \u0026lt;new\u0026gt; namespace QUEUE { enum Priority { Urgent = 1, Highest, High, Middle, Low, Minimum }; class CTaskBase { public: Priority priority; CTaskBase() { is_virtual = 0; argv = NULL; } virtual ~CTaskBase(){} virtual int Start() { return 0; } bool operator () (CTaskBase* \u0026amp;a, CTaskBase* \u0026amp;b) { return !((*a) \u0026lt; (*b)); } bool operator () (CTaskBase \u0026amp;a, CTaskBase \u0026amp;b) { return !(a \u0026lt; b); } bool operator \u0026lt; (const CTaskBase \u0026amp;a) const { return (bool)((int)priority \u0026lt; (int)a.priority); } protected: void *argv; int is_virtual; }; template \u0026lt;class Type\u0026gt; class CTaskQueue : public CTaskBase { public: union { int (Type::*func)(void*); int (*CallBack)(Type*, void*); }func; CTaskQueue() { ClassName = NULL; func.func = NULL; } ~CTaskQueue() { Clear(); } void Clear() { argv = NULL; ClassName = NULL; func.func = NULL; } int SetFunc(Priority priority, Type* ClassName, int (Type::*Func)(void*), void* argv) { this-\u0026gt;priority = priority; this-\u0026gt;ClassName = ClassName; this-\u0026gt;argv = argv; this-\u0026gt;func.func = Func; return 1; } int Start() { //return func.CallBack(ClassName, argv); return (ClassName-\u0026gt;*(func.func))(argv); } private: Type* ClassName; }; template\u0026lt;typename _Tp, typename _Sequence = std::vector\u0026lt;_Tp\u0026gt;, typename _Compare = std::less\u0026lt;typename _Sequence::value_type\u0026gt; \u0026gt; class priority_queue { // concept requirements pthread_rwlock_t m_mutex; public: typedef typename _Sequence::value_type value_type; typedef typename _Sequence::reference reference; typedef typename _Sequence::const_reference const_reference; typedef typename _Sequence::size_type size_type; typedef _Sequence container_type; protected: // See queue::c for notes on these names. _Sequence c; _Compare comp; public: explicit priority_queue(const _Compare\u0026amp; __x = _Compare(), const _Sequence\u0026amp; __s = _Sequence()) : c(__s), comp(__x) { pthread_rwlock_init(\u0026amp;m_mutex, NULL); std::make_heap(c.begin(), c.end(), comp); } template\u0026lt;typename _InputIterator\u0026gt; priority_queue(_InputIterator __first, _InputIterator __last, const _Compare\u0026amp; __x = _Compare(), const _Sequence\u0026amp; __s = _Sequence()) : c(__s), comp(__x) { pthread_rwlock_init(\u0026amp;m_mutex, NULL); __glibcxx_requires_valid_range(__first, __last); c.insert(c.end(), __first, __last); std::make_heap(c.begin(), c.end(), comp); } bool empty() { pthread_rwlock_wrlock(\u0026amp;m_mutex); bool e = c.empty(); pthread_rwlock_unlock(\u0026amp;m_mutex); return e; } size_type size() { pthread_rwlock_wrlock(\u0026amp;m_mutex); size_type _size = c.size(); pthread_rwlock_unlock(\u0026amp;m_mutex); return _size; } const_reference top() { pthread_rwlock_wrlock(\u0026amp;m_mutex); const_reference reference_value = c.front(); return reference_value; } void push(const value_type\u0026amp; __x) { pthread_rwlock_wrlock(\u0026amp;m_mutex); c.push_back(__x); std::push_heap(c.begin(), c.end(), comp); pthread_rwlock_unlock(\u0026amp;m_mutex); } void pop() { std::pop_heap(c.begin(), c.end(), comp); c.pop_back(); pthread_rwlock_unlock(\u0026amp;m_mutex); } }; typedef priority_queue\u0026lt;CTaskBase*, std::vector\u0026lt;CTaskBase*\u0026gt;, CTaskBase\u0026gt; queue_priority; }; #endif 线程池与连接池文件代码： {% codeblock lang:cpp %} /*******************************************************************************\nAuthor : RKhuwq Email : sohunjug@hotmail.com Last modified : 2013-11-18 16:55 Filename : Pool.h Description : *****************************************************************************/ #ifndef POOL_H #define POOL_H\n#include \u0026lt;pthread.h\u0026gt; #include #include \u0026lt;stdio.h\u0026gt; #include \u0026ldquo;TaskQueue.h\u0026rdquo; #include \u0026lt;signal.h\u0026gt;\nnamespace POOL { enum PoolStatue { Wait = 1, Kill }; class CPoolBase { protected: int m_init; int m_iNum; int m_iCount; pthread_attr_t m_attr; virtual void Create() = 0; virtual int ControlThread(void* argv) = 0; public: PoolStatue statues; pthread_mutex_t m_mutex; pthread_mutexattr_t m_mutexAttr; CPoolBase(int num, PoolStatue statue) : m_init(num), m_iNum(5), m_iCount(0), statues(statue) { pthread_attr_init(\u0026amp;m_attr); pthread_attr_setdetachstate(\u0026amp;m_attr,PTHREAD_CREATE_JOINABLE); pthread_mutexattr_init(\u0026amp;m_mutexAttr); pthread_mutex_init(\u0026amp;m_mutex, \u0026amp;m_mutexAttr); } virtual ~CPoolBase() { pthread_mutexattr_destroy(\u0026amp;m_mutexAttr); }; };\nclass CThreadPool : public CPoolBase { struct pthread_statue { pthread_t pthread_id; int statue; pthread_mutex_t m_threadMutex; pthread_cond_t m_threadCond; }; public: std::map\u0026lt;pthread_t, pthread_statue*\u0026gt; m_mthread; std::map\u0026lt;pthread_t, pthread_statue*\u0026gt;::iterator m_iter; QUEUE::queue_priority\u0026amp; queue; private: bool is_clear; pthread_mutex_t m_mutexCount; QUEUE::CTaskQueue\u0026lt;CThreadPool\u0026gt; *owntask; void Create() { pthread_statue *new_pthread = new pthread_statue(); pthread_mutex_lock(\u0026amp;m_mutex); if(pthread_create(\u0026amp;new_pthread-\u0026gt;pthread_id, \u0026amp;m_attr, ThreadMain, this)!=0) { return ; } m_mthread.insert(std::pair\u0026lt;pthread_t, pthread_statue*\u0026gt; (new_pthread-\u0026gt;pthread_id, new_pthread)); pthread_mutex_unlock(\u0026amp;m_mutex); pthread_mutex_lock(\u0026amp;m_mutexCount); m_iCount++; pthread_mutex_unlock(\u0026amp;m_mutexCount); } int ControlThread(void* argv) { int in_count_add = 0; int in_count_del = 0; int task_count; bool change; CThreadPool* pclass = (CThreadPool*)argv; pthread_statue *statue_self; std::map\u0026lt;pthread_t, pthread_statue*\u0026gt;::iterator iter; pthread_mutex_lock(\u0026amp;pclass-\u0026gt;m_mutex); statue_self = pclass-\u0026gt;m_mthread.find(pthread_self())-\u0026gt;second; pthread_mutex_unlock(\u0026amp;pclass-\u0026gt;m_mutex); statue_self-\u0026gt;statue = 1; while(1) { while (m_iCount \u0026lt; m_init \u0026amp;\u0026amp; m_iCount \u0026lt; m_iNum \u0026amp;\u0026amp; ((statues == Wait \u0026amp;\u0026amp; !queue.empty()) || !is_clear)) { Create(); } task_count = queue.size(); if (task_count) { pthread_mutex_lock(\u0026amp;m_mutex); iter = m_mthread.begin(); while (iter != m_mthread.end() \u0026amp;\u0026amp; ((statues == Wait \u0026amp;\u0026amp; !queue.empty()) || !is_clear)) { if (iter-\u0026gt;second-\u0026gt;statue == 2 \u0026amp;\u0026amp; iter-\u0026gt;second-\u0026gt;pthread_id != pthread_self()) { pthread_cond_signal (\u0026amp;iter-\u0026gt;second-\u0026gt;m_threadCond); break; } iter++; } if (iter == m_mthread.end()) m_iNum ++; pthread_mutex_unlock(\u0026amp;m_mutex); if (task_count \u0026gt; m_iCount) { in_count_add++; in_count_del = 0; } else if (task_count \u0026lt; m_iCount) { //in_count_del++; in_count_add = 0; } if (in_count_add \u0026gt; 10) { in_count_add = 0; m_iNum++; change = true; } if (in_count_del \u0026gt; 10 \u0026amp;\u0026amp; m_iNum \u0026gt; m_init) { m_iNum--; change = true; } } if (task_count == 0) usleep(100); if ((statue_self-\u0026gt;statue == 0 || is_clear) \u0026amp;\u0026amp; !(statues == Wait \u0026amp;\u0026amp; !queue.empty())) { pthread_mutex_lock(\u0026amp;m_mutexCount); pclass-\u0026gt;m_iCount--; pthread_mutex_unlock(\u0026amp;m_mutexCount); break; } } return 0; } public: static void* ThreadMain(void *arg) { pthread_statue* statue_self; CThreadPool* pclass = (CThreadPool*)arg; QUEUE::CTaskBase* task = NULL; pthread_mutex_lock(\u0026amp;pclass-\u0026gt;m_mutex); statue_self = pclass-\u0026gt;m_mthread.find(pthread_self())-\u0026gt;second; pthread_mutex_unlock(\u0026amp;pclass-\u0026gt;m_mutex); pthread_mutex_init (\u0026amp;statue_self-\u0026gt;m_threadMutex, \u0026amp;pclass-\u0026gt;m_mutexAttr); pthread_cond_init (\u0026amp;statue_self-\u0026gt;m_threadCond, NULL); statue_self-\u0026gt;statue = 1; //timespec time; statue_self-\u0026gt;pthread_id = pthread_self(); while(1) { if (pclass-\u0026gt;statues != Wait || pclass-\u0026gt;queue.empty()) { if (statue_self-\u0026gt;statue == 0) { pthread_mutex_lock(\u0026amp;pclass-\u0026gt;m_mutexCount); pclass-\u0026gt;m_iCount--; pthread_mutex_unlock(\u0026amp;pclass-\u0026gt;m_mutexCount); break; } } task = NULL; pthread_mutex_lock(\u0026amp;pclass-\u0026gt;m_mutex); if(pclass-\u0026gt;queue.empty()) { if (pthread_mutex_trylock(\u0026amp;statue_self-\u0026gt;m_threadMutex) != 0) { pthread_mutex_unlock(\u0026amp;pclass-\u0026gt;m_mutex); continue; } pthread_mutex_unlock(\u0026amp;pclass-\u0026gt;m_mutex); statue_self-\u0026gt;statue = 2; pthread_cond_wait(\u0026amp;statue_self-\u0026gt;m_threadCond, \u0026amp;statue_self-\u0026gt;m_threadMutex); pthread_mutex_unlock(\u0026amp;statue_self-\u0026gt;m_threadMutex); continue; } task=pclass-\u0026gt;queue.top(); pclass-\u0026gt;queue.pop(); pthread_mutex_unlock(\u0026amp;pclass-\u0026gt;m_mutex); if (task) { statue_self-\u0026gt;statue = 1; if (task-\u0026gt;Start() != 0) { } if (!task) delete task; } } return NULL; } void Stop(pthread_t pthread_id) { pthread_statue *temp; pthread_mutex_lock(\u0026amp;m_mutex); temp = m_mthread.find(pthread_id)-\u0026gt;second; pthread_mutex_unlock(\u0026amp;m_mutex); if (!temp) return; while(pthread_kill(temp-\u0026gt;pthread_id, 0) == 0) { pthread_mutex_lock(\u0026amp;temp-\u0026gt;m_threadMutex); temp-\u0026gt;statue = 0; pthread_mutex_unlock(\u0026amp;temp-\u0026gt;m_threadMutex); pthread_cond_signal(\u0026amp;temp-\u0026gt;m_threadCond); usleep(10000); } pthread_mutex_lock(\u0026amp;m_mutex); temp = m_mthread.find(pthread_id)-\u0026gt;second; m_mthread.erase(pthread_id); pthread_mutex_unlock(\u0026amp;m_mutex); delete temp; } void ClearQueue() { while (!queue.empty()) { delete queue.top(); queue.pop(); } } void Clear() { is_clear = true; pthread_mutex_lock(\u0026amp;m_mutex); std::map\u0026lt;pthread_t, pthread_statue*\u0026gt;::iterator iter = m_mthread.begin(); for (; iter != m_mthread.end(); iter = m_mthread.begin()) { pthread_mutex_unlock(\u0026amp;m_mutex); Stop(iter-\u0026gt;first); pthread_mutex_lock(\u0026amp;m_mutex); } pthread_mutex_unlock(\u0026amp;m_mutex); } public: CThreadPool(int num, QUEUE::queue_priority\u0026amp; queue, PoolStatue Pool = Wait) : CPoolBase(num, Pool), queue(queue), is_clear(false) { pthread_mutex_init (\u0026amp;m_mutexCount, NULL); owntask = new QUEUE::CTaskQueue\u0026lt;CThreadPool\u0026gt;; owntask-\u0026gt;SetFunc(QUEUE::Urgent, this, \u0026amp;CThreadPool::ControlThread, this); queue.push(owntask); Create(); } ~CThreadPool() { if (statues == Wait) Clear(); ClearQueue(); if (statues != Wait) Clear(); } }; template\u0026lt;typename CConnectionClass\u0026gt; class CConnectPool : public CPoolBase { private: std::map\u0026lt;CConnectionClass*, pthread_mutex_t\u0026gt; m_mapConnection; typename std::map\u0026lt;CConnectionClass*, pthread_mutex_t\u0026gt;::iterator m_iter; bool is_clear; typedef bool (CConnectionClass::*Connect)(const char*, const char*, const char*); typedef void (CConnectionClass::*Close)(void); Connect m_fconnect; Close m_fclose; char* m_sConnectParam[3]; int m_iUsed; pthread_mutex_t m_mapmutex; public: CConnectPool(int num) : CPoolBase(num, Wait), m_iUsed(0) { is_clear = false; m_mapConnection.clear(); m_sConnectParam[0] = NULL; m_sConnectParam[1] = NULL; m_sConnectParam[2] = NULL; pthread_mutex_init(\u0026amp;m_mapmutex, NULL); } ~CConnectPool() { Clear(); free(m_sConnectParam[0]); free(m_sConnectParam[1]); free(m_sConnectParam[2]); } void Clear() { is_clear = true; m_iter = m_mapConnection.begin(); while (m_iter != m_mapConnection.end()) { if (pthread_mutex_trylock(\u0026amp;m_iter-\u0026gt;second) == 0) { (m_iter-\u0026gt;first-\u0026gt;*(m_fclose))(); delete m_iter-\u0026gt;first; m_mapConnection.erase(m_iter); m_iter = m_mapConnection.begin(); pthread_mutex_lock(\u0026amp;m_mutex); m_iCount --; pthread_mutex_unlock(\u0026amp;m_mutex); } else m_iter++; if (m_iter == m_mapConnection.end()) m_iter = m_mapConnection.begin(); } m_mapConnection.clear(); } void SetFunc(Connect connect, Close close, char* value[]) { m_fconnect = connect; m_fclose = close; m_sConnectParam[0] = (char*)malloc(strlen(value[0]) + 1); m_sConnectParam[1] = (char*)malloc(strlen(value[1]) + 1); m_sConnectParam[2] = (char*)malloc(strlen(value[2]) + 1); strcpy(m_sConnectParam[0], value[0]); strcpy(m_sConnectParam[1], value[1]); strcpy(m_sConnectParam[2], value[2]); } CConnectionClass* GetConnection() { pthread_mutex_lock(\u0026amp;m_mapmutex); int count = 0; m_iter = m_mapConnection.begin(); while (1) { if (m_iter == m_mapConnection.end()) { count ++; m_iter = m_mapConnection.begin(); if (count \u0026gt; 10) { Create(); pthread_mutex_lock(\u0026amp;m_mutex); m_iNum++; pthread_mutex_unlock(\u0026amp;m_mutex); m_iter = m_mapConnection.begin(); } } if (m_iter != m_mapConnection.end()) if (pthread_mutex_trylock(\u0026amp;m_iter-\u0026gt;second) == 0) { pthread_mutex_lock(\u0026amp;m_mutex); m_iUsed++; pthread_mutex_unlock(\u0026amp;m_mutex); pthread_mutex_unlock(\u0026amp;m_mapmutex); return m_iter-\u0026gt;first; } else m_iter++; } pthread_mutex_unlock(\u0026amp;m_mapmutex); return NULL; } void BackConnection(CConnectionClass* oneConnect) { if (!oneConnect) return; pthread_mutex_lock(\u0026amp;m_mapmutex); pthread_mutex_unlock(\u0026amp;m_mapConnection.find(oneConnect)-\u0026gt;second); pthread_mutex_unlock(\u0026amp;m_mapmutex); pthread_mutex_lock(\u0026amp;m_mutex); m_iUsed--; pthread_mutex_unlock(\u0026amp;m_mutex); } void Create() { pthread_mutex_t rwlock; pthread_mutex_init(\u0026amp;rwlock, NULL); pthread_mutex_lock(\u0026amp;m_mutex); CConnectionClass* oneConnect = new CConnectionClass(); (oneConnect-\u0026gt;*(m_fconnect))(m_sConnectParam[0], m_sConnectParam[1], m_sConnectParam[2]); m_mapConnection.insert(std::pair\u0026lt;CConnectionClass*, pthread_mutex_t\u0026gt; (oneConnect, rwlock)); m_iCount ++; pthread_mutex_unlock(\u0026amp;m_mutex); } int Count() { return m_mapConnection.size(); } int ControlThread(void* argv) { int in_count_add = 0; int in_count_del = 0; int task_count; int second = 10000; bool change; while(1) { task_count = this-\u0026gt;Count(); if (task_count \u0026lt;= m_iNum) { pthread_mutex_lock(\u0026amp;m_mapmutex); Create(); pthread_mutex_unlock(\u0026amp;m_mapmutex); } if (m_iUsed \u0026gt; 0) if (task_count) { if (task_count \u0026gt; m_iUsed) in_count_del++; if (in_count_del \u0026gt; 10) change = true; } if (task_count != 0) usleep(second); if (is_clear) break; } return 0; } }; };\n#endif {% endcodeblock %}\n测试文件代码： {% codeblock lang:cpp %} #include \u0026lt;stdio.h\u0026gt; #include \u0026ldquo;Pool.h\u0026rdquo; #include \u0026ldquo;TaskQueue.h\u0026rdquo; #include \u0026ldquo;DBDatabase.h\u0026rdquo; #include \u0026ldquo;DBStatement.h\u0026rdquo;\nusing namespace POOL;\nusing namespace QUEUE; class B { public: B(){printf(\u0026ldquo;B\\n\u0026rdquo;);} virtual int process(void* arg){return 0;}; virtual ~B(){printf(\u0026ldquo;B\\n\u0026rdquo;);} }; class A : public B { public: A(){} ~A(){} int process(void* arg) { char** argv = (char**)arg; for (int iLoop = 0; iLoop \u0026lt; 2; iLoop++) { printf(\u0026quot;%s \u0026ldquo;, argv[iLoop]); } printf(\u0026quot;\\n\u0026rdquo;); return 0; } };\nint main(int argc, char** argv) { CThreadPool threadpool(2, task_priority_queue); char conn[3][20] = {\u0026ldquo;system\u0026rdquo;, \u0026ldquo;system\u0026rdquo;, \u0026ldquo;tsdc\u0026rdquo;}; char value[3]; value[0] = conn[0]; value[1] = conn[1]; value[2] = conn[2]; CConnectPool connnectpool(5); connnectpool.SetFunc(\u0026amp;CDBDatabase::Connect, \u0026amp;CDBDatabase::Disconnect, value); int count = 0; A p; CTaskQueue\u0026lt;CConnectPool \u0026gt; atask = new CTaskQueue\u0026lt;CConnectPool \u0026gt;; char se[10] = \u0026ldquo;10000000\u0026rdquo;; char s[2]; s[0] = se; s[1] = NULL; atask-\u0026gt;SetFunc(Highest, \u0026amp;connnectpool, \u0026amp;CConnectPool::ControlThread, s); task_priority_queue.push(atask); CDBDatabase temp = connnectpool.GetConnection(); CDBDatabase temp2 = connnectpool.GetConnection(); CDBStatement dbstatement = new CDBStatement(temp); CDBStatement dbs = new CDBStatement(temp2); dbstatement-\u0026gt;Prepare(\u0026ldquo;select city_code from bb_device_rent_info_t where user_id = 48303537\u0026rdquo;); dbs-\u0026gt;Prepare(\u0026ldquo;select user_id from bb_device_rent_info_t where user_id = 48303537\u0026rdquo;); dbstatement-\u0026gt;Open(); dbs-\u0026gt;Open(); if (dbstatement-\u0026gt;Next() \u0026amp;\u0026amp; dbs-\u0026gt;Next()) { printf(\u0026quot;%s\\n\u0026quot;, dbstatement-\u0026gt;Field(0).AsString()); printf(\u0026quot;%s\\n\u0026quot;, dbs-\u0026gt;Field(0).AsString()); } connnectpool.BackConnection(temp); connnectpool.BackConnection(temp2); while(1) { char time[2][10]; char ttt[3]; sprintf(time[0], \u0026ldquo;time:\u0026rdquo;); sprintf(time[1], \u0026ldquo;%d\u0026rdquo;, count++); ttt[0] = time[0]; ttt[1] = time[1]; ttt[2] = NULL; CTaskQueue task = new CTaskQueue; task-\u0026gt;SetFunc(Low, \u0026amp;p, \u0026amp;A::process, (void)ttt); task_priority_queue.push(task); usleep(1000000); }\nA a; CTaskQueue\u0026lt;A\u0026gt;* task = new CTaskQueue\u0026lt;A\u0026gt;; char aaa[2][10] = {\u0026quot;aaa\u0026quot;, \u0026quot;bbb\u0026quot;}; char *aa[3]; char *bb[3]; aa[0] = aaa[0]; aa[1] = aaa[1]; aa[2] = NULL; task-\u0026gt;SetFunc(Low, \u0026amp;a, \u0026amp;A::process, (void*)aa); task_priority_queue.push(task); char bbb[2][10] = {\u0026quot;ccc\u0026quot;, \u0026quot;bbb\u0026quot;}; bb[0] = bbb[0]; bb[1] = bbb[1]; bb[2] = NULL; task = new CTaskQueue\u0026lt;A\u0026gt;; task-\u0026gt;SetFunc(Minimum, \u0026amp;a, \u0026amp;A::process, (void*)bb); //task_priority_queue.push(task); connnectpool.Clear(); usleep(30000); threadpool.Clear(); return 0; } {% endcodeblock %} github: GitLink\u0026hellip;.\n可能还有bug,还有很多不足，欢迎大家帮忙测试.\n","date":"2013-11-28T00:00:00+08:00","permalink":"https://sohunjug.com/2013/11/28/%E5%9F%BA%E4%BA%8E%E7%B1%BB%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%9B%9E%E8%B0%83%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0-%E8%BF%9E%E6%8E%A5%E6%B1%A0-%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/","title":"基于类成员函数回调的线程池-连接池-任务队列"},{"content":"最近因为任务需要，专门调研了一下MongoDB数据库的效率。与常规的OracleDB做了一下对比。\nMongoDB是一个基于分布式文件存储的数据库。由C++语言编写。旨在为WEB应用提供可扩展的高性能数据存储解决方案。 他支持的数据结构非常松散，是类似json的bjson格式，因此可以存储比较复杂的数据类型。Mongo最大的特点是他支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。 Mongodb的存储方式是文档式存储，并不是Key-Value形式。 Mongodb的主要的三种集群方式的搭建：Replica Set、 Sharding、 Master-Slaver。 其他大部分内容互联网上也有很多，我也就不再做介绍了。\n主要测试时设备环境以及数据格式\n设备环境\n175、176服务器：\nCPU：8核\n内存：32G（空闲19G）\n硬盘：4TB\n系统：Red Hat 6.3\n网络：千兆光纤\n.\n165数据库服务器：\nCPU：8核\n内存：16G\n硬盘：2TB\n系统：Red Hat 4\n网络：百兆光纤\n数据格式\n每条数据包含6个字段。 字段名为:usr, pwd, age, email, address, phone 每个字段均为整形，每个字段内容为当前条数，如：第100条数据，每个字段内容为100。\n一、oracle数据库入库测试\n数据库环境:165数据库，表结构：hash分区16个，usr字段唯一索引\n入库条数：10,000,000\n1 单条数据入库\n总入库时间2836s（不包含创建连接以及句柄时间）约47.3分钟。\n2 批量数据入库\n2.1 每批次数据量50,000\n总入库时间564s，约9.4分钟。\n2.2 每批次数据量100,000\n总入库时间553s，约9.2分钟。\n二、mongodb入库测试\n1 主从备份数据库配置(主从复制)（Master-Slaver）\n比较初级的构架，配置简单。\n1.1 数据库环境（无索引）\n数据库环境：176主节点，175为备份节点，内容时时同步。无索引（索引可以在查询之前建立）。\n1.1.1 入库数据量10,000,000\n总入库时间355s，约5.9分钟。\n从头遍历一次时间13s。\n1.1.2 入库数据量50,000,000\n总入库时间1815s，约30.25分钟\n从头遍历一次时间58s\n注：推荐每次插入前删除索引，插入后重新建立索引，减少插入数据时对索引的处理时间。\n1.2 数据库环境（有索引）\n数据库环境：176主节点，175为备份节点，内容时时同步。usr字段索引。先建立索引\n1.2.1 入库数据量10,000,000\n总入库时间418s，约6.97分钟。\n从头遍历一次时间11s。\n1.2.2 入库数据量50,000,000（放弃）\n入库25,000,000数据大概1小时，后续时间持续增长，速度过慢。\n注：网上资料提供说：这种先写后读的需求，完全可以等全部插入后再建索引，防止大量的锁竞争。\n2 mongodb高可用性架构—Replica Set (副本集)\n2.1 数据库环境\n数据库环境：主节点10.4.120.176:27017，从节点10.4.120.175:27017，仲裁节点10.4.120.176:17017。\n作用：当主节点宕机或停电，从节点与仲裁节点进行投票，选择票数大于总主机数一半的从主机为新的主节点。保证服务正常运转。\n2.1.1 入库数据量50,000,000(无索引)\n总入库时间2348s，约39.5分钟。\n从头遍历一次时间58s。\n注：\n1.大部分网络上的构架应该是这种的升级版（主要为后期数据库调优）。\n2.入库后新建索引大概时间为5分钟。\n3 MongoDB分布式主备集群架构\n本架构为2章节介绍中1和2架构的结合\n集群子集r0主备：主服务器176:10000，备服务器175:20000，仲裁服务器176:10001。\n集群子集r1主备：主服务器175:10000，备服务器176:20000，仲裁服务器175:10001。\n将r0，r1子集架构为分布式集群，自动分片。\n3.1.1 入库数据量10,000,000\n总入库时间618s，约10.3分钟。\n从头遍历一次时间34s。\n本次测试包含：插入过程中将某个子集主节点kill掉模拟服务器故障，过1分钟后重新启动该节点主服务器进程，持续插入进程继续，当最后插入结束时，数据丢失1条。\n3.1.2 入库数据量20,000,000\n多进程入库，每个进程入库10,000,000\n总入库时间1315s，约21.9分钟。\n3.1.3 入库数据量50,000,000\n总入库时间2771s，约46.2分钟。\n从头遍历一次时间160s。\n三、总结\n通过下方的表格可以看出，当处理数据多时，MongoDB效率基本不会改变，而OracleDB效率慢的地方是执行sql语句的时间，当某些业务需求必须单独执行sql时，MongoDB的效率约为OracleDB的5倍。\n其中商业架构主推分布式主备集群的架构方式，此方式可以实现数据时时备份，且数据分布式存储，可以实现当某一台主机宕机，无需暂停业务处理。数据丢失情况，为宕机前100ms内执行的数据，约为数据的千万分之一。\n个人认为MongoDB单机的效率虽然非常高，但可用性低，而分布式架构适合数据重要性不强情况，能实现远超oracle的效率，分布式主备架构是可用性、安全性最高的架构方式，前期的效率可能会等同于oracle，但当数据量过大时，会超过oracle效率。实现水平扩展，将计算能力提升到最大。\n","date":"2013-08-26T00:00:00+08:00","permalink":"https://sohunjug.com/2013/08/26/mongodb%E4%B8%8Eoracledb%E6%95%88%E7%8E%87%E6%B5%8B%E8%AF%95/","title":"MongoDB与OracleDB效率测试"},{"content":"这篇文章主要介绍了在Mac OS X 10.8.4、Ubuntu 13.04 x64和Windows 7 x64三个系统平台下对MacBook Pro（以下简称：MBP）的风扇控制，因为不知道为什么的原因，我个人和不少人的MBP都表现出风扇调速迟钝的问题，通常都是2000RPM左右，然后等到机器超过90摄氏度后风扇开始提速到6000RPM进行散热，但这个肯定不是我们需要的效果，我们要的是，要么自己控制，要么自动调整。\n目前，本人的电脑装的是三系统共存，就是Mac OS X 10.8.4、Ubuntu 13.04 x64和Windows 7 x64\n这个身为MBP原生的，与硬件契合度最高的系统同样存在风扇自动调整的问题，至少在我重置了N次SMC的情况依然还是只能达到90度附近才会提速，于是只能用软件来对付了，我个人觉得效果比较好的是Fan Control。\n名称：Fan Control\n下载：http://www.lobotomo.com/products/FanControl/\n安装之后，会在“系统偏好设置”里面增加一个叫“Fan Control”的设置面板。\n进去之后三项设置，\nBase Speed，初始速度，系统默认是2000RPM，系统启动之后会以这个初始速度为基准；\nLower Threshold，温度下限阀值，这个是配合Base Speed工作的，在这个温度下，转速是Base Speed；\nUpper Threshold，温度上限阀值，这个是值达到时系统将以最高转速跑风扇，我的MBP 13是6200。\n风扇的转速会自动在Lower和Upper之间自动调整。\nUbuntu 13.04 x64\n遇到Linux有个好处，直接修改配置文件就行，可以省掉软件了，但是这个没法进行曲线调速了，所以有的人是直接把速度一步到位直接上到5500RPM，喜欢6000RPM的也行，反正风扇的作用就是处理积热嘛~\n不过我个人只是上班使用linux，所以我设置3800就完全够用了，一点不热，感觉灰常好啊~\n操作如下：\n开启终端（Terminal），输入以下指令，之后需要输入你当前用户的密码，然后回车， {% codeblock lang:bash %} sudo sh -c \u0026ldquo;echo 5000 \u0026gt; /sys/devices/platform/applesmc.768/fan1_min\u0026rdquo; {% endcodeblock %}\n通过修改fan1_min中的数字“1”，可以调整各个不同风扇的转速，因为MBP 13只有一个风扇，所以也只有fan1，像MBP 15这一类的，可以分别调整fan1和fan2的转速等。并且每次开机的话系统都会自动重置，所以如果需要每次开机都保持一个转速的话，可以自行修改rc脚本。\nWindows 7 x64\n在Windows下也是需要依靠第三方软件的，据说是有类似于OSX下Fan Control那样的自动调速软件，不过我个人还是比较喜欢把速度调整到4000左右，基本也就够用了。软件叫“Mac/SMC Fan Control for Windows (+ Temp) ”。\n名称：Mac/SMC Fan Control for Windows (+ Temp)\n平台：32-bit MS Windows (NT/2000/XP/7/8/8.1), 64-bit MS Windows 7/8/8.1, Vista, WinXP.\n下载：http://sourceforge.net/projects/macfan/\n官方没有提到Win7，但是我的Win7-64bit也没有问题的。这是一个基于CLI（CommandLine Interface，命令行界面）的程序，而且同时还需要管理员权限，还要带参数，使用起来稍微有点麻烦，我个人是这么处理的：\n1.首先将解压缩后的文件放在\\windows\\mf目录；\n2.同时在目录里面增加一个批处理文件mf.cmd，内容如下： {% codeblock lang:bat %} @echo off @echo Input the fan speed (2000-6200): set /p speed= C:\\Windows\\mf\\MacFanx64.exe %speed% {% endcodeblock %} 3.之后按住Alt键，把mf.cmd拖到桌面上，之后在mf.cmd上右键，选择“属性”，选择“快捷方式”页面，点击“高级”，之后把“以管理员权限运行”勾上。\n4.双击桌面上的“mf.cmd – 快捷方式”，之后输入你想要调整的风扇转速，回车即可。\n因为我的是MBP 13，只有一个风扇，所以只需要提供一个参数，如果有多个风扇的话，请依据自己的需要进行修改，按照\n基本上，我现在三系统使用的很完美，win7只是下个电影或者游戏下，平时上班linux，下班mac~\n引用参考：\nFan Control: http://www.lobotomo.com/products/FanControl/\nMacFan: http://sourceforge.net/projects/macfan/\nUbuntu Forum: http://ubuntuforums.org/showthread.php?t=1378663\n","date":"2013-07-26T00:00:00+08:00","permalink":"https://sohunjug.com/2013/07/26/macbook-pro-fan-control/","title":"MacBook Pro – Fan Control"},{"content":"大家在写代码的时候是否有忘记free指针的时候呢？\n如果是大型项目肯定会用一些比较稳定的开源库一类的来解决。而如果是私人的小项目，或者是测试一类的代码遇到这类问题还需要各种检查，是否很浪费时间呢？\n给大家分享一个我个人使用的内存管理类哈~可以使用Create一块空间，之后可以不需要去管这块空间最后是否free掉，因为类析构时候会自动帮助free掉，而如果想要手动free也支持，直接传入申请空间时候取得的ID就可以指定析构了。这个还是比较适合私人用用哈~\n首先是头文件~ {% codeblock lang:cpp %}/*******************************************************************************\nAuthor : RKhuwq Email : huwq@neusoft.com Last modified : 2013-04-07 18:34 Filename : MemCtrl.h Description : 内存管理类，类析构时自动释放内存。 用于给指针申请内存空间。 *****************************************************************************/ #ifndef MEMCTRL_H #define MEMCTRL_H #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include #include class CMemCtrl { private: typedef struct DATA_SPACE { void* point; DATA_SPACE* Next; DATA_SPACE* Pre; int count;\n_DATA_SPACE_() { point = NULL; Next = NULL; Pre = NULL; count = 0; } ~_DATA_SPACE_() { if (point != NULL) free(point); if (Pre != NULL \u0026amp;\u0026amp; Next == NULL) Pre-\u0026gt;Next = NULL; else if (Pre == NULL \u0026amp;\u0026amp; Next != NULL) Next-\u0026gt;Pre = NULL; else if (Pre != NULL \u0026amp;\u0026amp; Next != NULL) { Pre-\u0026gt;Next = Next; Next-\u0026gt;Pre = Pre; } } void SetPre(_DATA_SPACE_* Pre) { this-\u0026gt;Pre = Pre; } }KDataSpace; typedef KDataSpace* PDataSpace; public: CMemCtrl(); ~CMemCtrl(); //申请空间 void* Create(int x, int size); //指定ID释放空间 void Clear(int count); //释放所有已申请空间 bool Reset(); //取得最近一次所申请的空间ID int GetCount(); private: void Clear(); void* point_one; std::vector\u0026lt;int\u0026gt; vCount; PDataSpace header; PDataSpace end; PDataSpace point; int count_one; };\n#endif {% endcodeblock %}\n下面就是具体的实现了~ {% codeblock lang:cpp %} /*******************************************************************************\nAuthor : RKhuwq Email : huwq@neusoft.com Last modified : 2013-04-07 18:34 Filename : MemCtrl.h Description : 内存管理类，类析构时自动释放内存。 用于给指针申请内存空间。 *****************************************************************************/ #include \u0026ldquo;MemCtrl.h\u0026rdquo; CMemCtrl::CMemCtrl() { header = NULL; end = NULL; count_one = 0; }\nCMemCtrl::~CMemCtrl() { Clear(); }\nvoid CMemCtrl::Clear() { while(header != NULL) { point = header-\u0026gt;Next; delete header; header = point; } header = NULL; end = NULL; count_one = 0; }\nvoid CMemCtrl::Clear(int count) { PDataSpace temp; temp = end; point = temp; while(point != NULL \u0026amp;\u0026amp; point-\u0026gt;count != count) { point = temp-\u0026gt;Pre; temp = point; } vCount.push_back(point-\u0026gt;count); if (point == header) header = header-\u0026gt;Next; if (point == end) end = end-\u0026gt;Pre; if (point != NULL) { delete point; }\npoint = NULL; }\nint CMemCtrl::GetCount() { return end-\u0026gt;count; }\nvoid* CMemCtrl::Create(int x, int size) { std::vector::iterator vCountIte; point_one = NULL; point_one = (void*)calloc(x, size); if (point_one == NULL) return NULL; point = new KDataSpace(); if (point == NULL) return NULL; point-\u0026gt;point = point_one; while ((vCountIte = find(vCount.begin(), vCount.end(), count_one-1)) != vCount.end()) { count_one\u0026ndash;; vCount.erase(vCountIte); } if (vCount.size() \u0026gt; 0) { point-\u0026gt;count = vCount[0]; vCount.erase(vCount.begin()); } else { point-\u0026gt;count = count_one; count_one ++; }\nif (header == NULL) { header = point; end = point; } else { end-\u0026gt;Next = point; point-\u0026gt;SetPre(end); end = point; } return point_one; }\nbool CMemCtrl::Reset() { Clear(); return true; } {% endcodeblock %}\n","date":"2013-06-26T00:00:00+08:00","permalink":"https://sohunjug.com/2013/06/26/%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%B1%BB%E5%85%B3%E4%BA%8Emalloc%E4%B8%8Efree/","title":"简单的内存管理类（关于malloc与free）"},{"content":"在使用linux或者mac时，有时大家会写一些自己测试功能一类的小程序，可是如果只有1个文件时候还可以，直接gcc就OK了。\n而一旦文件多了以后可能就会很麻烦。这个makefile可以作为一个解决方案。\n首先自己修改需要生成的程序文件名的获取脚本，我是测试这类的小程序都在一个文件夹下分不同的子文件夹，所以在子文件夹外加入这个文件FileName.sh，不要忘记执行权限哦。（其中的awk自行更改哦，我的路径是/Users/sohunjug/Documents/sohunjug/） {% codeblock lang:bash %} FileName=`pwd | awk -Fsohunjug \u0026lsquo;{print $3}\u0026rsquo; | awk -F/ \u0026lsquo;{print $2}\u0026rsquo;` echo \u0026ldquo;$FileName\u0026rdquo; {% endcodeblock %}\n之后就可以将makefile考入需要的路径，然后执行make，就会生成以子文件夹名来命名的程序了～\n{% codeblock lang:makefile %}\ngcc编译通用的Makefile文件 ####################################################### FileName=`../FileName.sh` Exe=$(FileName) CC = g++ CFLAGS = -Wall -g\nOBJ_PATH = objs LINKFLAGS = -ldl -lpthread\n#Cpp文件夹 SRCDIR = .\nCPP_SRCDIR = $(SRCDIR) CPP_SOURCES = $(foreach d,$(CPP_SRCDIR),$(wildcard $(d)/*.cpp) ) CPP_OBJS = $(patsubst %.cpp, $(OBJ_PATH)/%.o, $(CPP_SOURCES))\ndefault: test init compile\n$(C_OBJS):$(OBJ_PATH)/%.o:%.c $(CC) -c $(CFLAGS) \u0026lt; -o $@\n$(CPP_OBJS):$(OBJ_PATH)/%.o:%.cpp $(CC) -c $(CFLAGS) \u0026lt; -o $@\ntest: @echo \u0026ldquo;$(FileName)\u0026rdquo; @echo \u0026ldquo;CPP_SOURCES: $(CPP_SOURCES)\u0026rdquo; @echo \u0026ldquo;CPP_OBJS: $(CPP_OBJS)\u0026rdquo;\ninit: $(foreach d,$(SRCDIR), mkdir -p $(OBJ_PATH)/$(d);)\ncompile:$(C_OBJS) $(CPP_OBJS) $(CC) $^ -o $(Exe) $(LINKFLAGS) $(LIBS)\nclean: rm -rf $(OBJ_PATH) rm -f $(Exe) ######################################################## {% endcodeblock %}\n","date":"2013-06-23T00:00:00+08:00","permalink":"https://sohunjug.com/2013/06/23/%E5%85%B3%E4%BA%8Emakefile%E7%9A%84%E9%80%9A%E7%94%A8%E6%96%B9%E6%A1%88%E4%B8%AA%E4%BA%BA%E6%B5%8B%E8%AF%95%E6%8E%A8%E8%8D%90%E6%96%B9%E6%A1%88/","title":"关于makefile的通用方案（个人测试推荐方案）"},{"content":"有人觉得脏数据是指错误的业务流程在系统中产生的无用异常数据。 产生这种数据的原因可能是因为错误的业务流程或者手动在数据库中制造。\n例如在百度百科中，对脏数据的定义是这样的，“脏数据是指源系统中的数据不在给定的范围内或对于实际业务毫无意义，或是数据格式非法，以及在源系统中存在不规范的编码和含糊的业务逻辑”。\n无论这种定义是否正确，在oracle中脏数据的定义不是这样的。在oracle中，脏数据是指在内存中而未写入硬盘的数据。脏数据块即为在内存中而未写入硬盘的数据块。\n那到底执行了commit语句之后，数据是否就立刻写到硬盘上了哪？事实上不是这样的，因为I/O操作是非常昂贵的，每次commit都写入硬盘会对系统造成巨大的压力。\n将内存数据块写入硬盘是一个相当复杂的过程。简单的说DBWn进程会定期将内存数据块写入硬盘，由CKPT后台进程确定写入的时间间隔。但是为了保证安全性，将由LGWR进程将redo日志写入联机日志，以备数据库实例崩溃时，恢复未写入硬盘的数据。\nDBWn：database writer\u0026mdash;\u0026gt; DBW n是数字,代表unix下多个数据库写进程。\nLGWR：Log Writer 将日志缓冲区中的所有记录项写到日志文件中。该进程在启动实例时自动启动。\nCKPT： 检验点进程。\n","date":"2012-12-24T00:00:00+08:00","permalink":"https://sohunjug.com/2012/12/24/%E5%85%B3%E4%BA%8E%E8%84%8F%E6%95%B0%E6%8D%AE%E8%84%8F%E6%95%B0%E6%8D%AE%E5%9D%97%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%AE%9A%E4%B9%89commit%E7%9A%84%E5%86%85%E9%83%A8%E6%9C%BA%E5%88%B6/","title":"关于脏数据、脏数据块的正确定义，commit的内部机制"},{"content":"Linux下开发人员时间长了会使用各种脚本，来增加开发效率，分享一个本人常使用的自动登录脚本。\n首先需要安装插件 {% codeblock lang:bash %} ubuntu apt-get install expect fedora yum install expect.x86_64 opensuse zypper install expect {% endcodeblock %} 之后就可以这么写脚本了，需要传参数 IP、用户名、密码、服务器的语言类型，可以使用locale命令查看。\n{% codeblock lang:bash%} #!/usr/bin/expect -f\nset user [lindex $argv 1] set host [lindex $argv 0] set password [lindex $argv 2] set lang [lindex $argv 3] set timeout -1\nspawn ssh $user@$host\nexpect { \u0026ldquo;yes/no\u0026rdquo; { send \u0026ldquo;yes\\r\u0026rdquo;;exp_continue }\n\u0026ldquo;assword:\u0026rdquo; { send \u0026ldquo;$password\\r\u0026rdquo; }\n} sleep 1 #send \u0026ldquo;export LANG=$lang \u0026amp;\u0026amp; export LC_ALL=$lang \\r\u0026rdquo;\ninteract {% endcodeblock %} 而登录的时候可以将密码等信息存入文件中，然后自动读取。如： {% codeblock lang:bash %} #!/bin/bash\nif [ -f $HOME/Documents/ssh/conn.profile ]; then source $HOME/Documents/ssh/conn.profile fi\nip=$1 CONIP=cat $HOME/Documents/ssh/conn.profile | grep CONNIP$ip | grep -v grep | awk -F= '{print \\$2}' CONUSER=cat $HOME/Documents/ssh/conn.profile | grep CONNUSER$ip | grep -v grep | awk -F= '{print \\$2}' CONPASS=cat $HOME/Documents/ssh/conn.profile | grep CONNPASS$ip | grep -v grep | awk -F= '{print \\$2}' CONLANG=cat $HOME/Documents/ssh/conn.profile | grep CONNLANG$ip | grep -v grep | awk -F= '{print \\$2}'\nif [ -z ${CONIP} ] then echo error: 没有那个IP else echo ${CONIP} echo ${CONUSER} echo ${CONPASS} echo ${CONLANG} export LANG=${CONLANG} \u0026amp;\u0026amp; export LC_ALL=${CONLANG} $HOME/Documents/ssh/sshend.sh ${CONIP} ${CONUSER} ${CONPASS} ${CONLANG} `qdbus org.kde.konsole $session org.kde.konsole.Session.setCodec UTF-8` export LANG=zh_CN.UTF-8 export LC_ALL=zh_CN.UTF-8 fi {% endcodeblock %} 给这个文件建立一个alias，之后直接登录加上标志，用ssh或者ftp等命令就方便了很多吧～\n","date":"2012-12-23T00:00:00+08:00","permalink":"https://sohunjug.com/2012/12/23/linux%E8%84%9A%E6%9C%AC/","title":"Linux脚本"},{"content":"以前在辽宁电信做数据转换的时候曾经问过别人一个问题，“修改的数据没有进行commit操作时，能否被其他用户查询到”，当时就被同事鄙视了，在大家眼里这个问题的结果是弱智和显而易见的，但是其实这是一个可以深入研究的问题。\n关于脏读 \u0026ldquo;修改的数据没有进行commit，可以被其它用户查到”，这种场景即为“脏读(dirty read)\u0026quot;。\n脏读存在的意义是为了实现非阻塞读(高并发无等待)，但是Oracle可以完全得到脏读的所有好处（即无阻塞），而不会带来任何不正确的结果，所以oracle不支持脏读，但是sqlserver等一些数据库是支持脏读的。\noracle是怎么实现这种机制的？当一条数据被修改而未进行commit时，当有其它用户查询这条数据时，oracle会绕过已修改的原数据，而是从undo段获得数据。因此可以返回一致而且正确的答案，而无需等待事务提交。\n关于隔离级别 标准sql的隔离级别如下\noracle提供了SQL92标准中的read committed和serializable，同时提供了非SQL92标准的read-only。由于oracle不支持read uncommited，所以oracle不支持脏读。oracle默认的的事务隔离级别为read commited。\nread uncommited的隔离级别最低， serializable的隔离级别最高。\n较低的隔离级别可以增强许多用户同时访问数据的能力，但也增加了用户可能遇到的并发副作用（例如脏读或丢失更新）的数量。相反，较高的隔离级别减少了用户可能遇到的并发副作用的类型，但需要更多的系统资源，并增加了一个事务阻塞其他事务的可能性。\n","date":"2012-12-23T00:00:00+08:00","permalink":"https://sohunjug.com/2012/12/23/%E6%B2%A1%E6%9C%89%E8%BF%9B%E8%A1%8Ccommit%E6%93%8D%E4%BD%9C%E7%9A%84%E6%95%B0%E6%8D%AE%E6%98%AF%E5%90%A6%E8%83%BD%E8%A2%AB%E6%9F%A5%E8%AF%A2%E5%88%B0%E5%85%B3%E4%BA%8Eoracle%E7%9A%84%E8%84%8F%E8%AF%BB%E5%92%8C%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/","title":"没有进行commit操作的数据是否能被查询到，关于oracle的脏读和隔离级别"},{"content":"我用vimrc，其中配置了函数列表，目录列表，函数跳转，定义跳转，xml排版，自动关联cscope和tags，快捷注释。\n其中需要下载一些插件才能用，比如我用的fedora，需要下载的列表为 {% codeblock %} vim-X11.x86_64 vim-common.x86_64 vim-enhanced.x86_64 vim-filesystem.x86_64 vim-halibut.noarch vim-minimal.x86_64 vim-perl-support.noarch cscope.x86_64 ctags.x86_64 {% endcodeblock %} 之后配置$HOME目录下的.vimrc\n{% codeblock lang:vim %} if has(\u0026ldquo;cscope\u0026rdquo;) set cscopequickfix=s-,c-,d-,i-,t-,e- set csto=0 set cst set csverb endif\n\u0026ldquo;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; \u0026ldquo;获取当前路径的上一级的路径 function! GET_UP_PATH(dir) let pos=strlen(a:dir)-1 while pos\u0026gt;0 if (a:dir[pos]==\u0026rdquo;/\u0026rdquo; ) return strpart(a:dir,0,pos) endif let pos=pos-1 endwhile return \u0026quot;\u0026quot; endfunction\n\u0026ldquo;设置相关tags function! s:SET_TAGS() let dir = getcwd() \u0026ldquo;获得源文件路径 \u0026ldquo;在路径上递归向上查找tags文件 while dir!=\u0026rdquo;\u0026rdquo; if findfile(\u0026ldquo;tags\u0026rdquo;,dir ) !=\u0026rdquo;\u0026quot; \u0026ldquo;找到了就加入到tags exec \u0026ldquo;set tags+=\u0026quot;.dir.\u0026quot;/tags\u0026rdquo; return endif \u0026ldquo;得到上级路径 let dir=GET_UP_PATH(dir) endwhile endfunction\n\u0026ldquo;设置php cscope.out function! SET_CSPHP() if(executable(\u0026lsquo;cscope\u0026rsquo;) \u0026amp;\u0026amp; has(\u0026ldquo;cscope\u0026rdquo;) ) silent! execute \u0026ldquo;!find . -name \u0026lsquo;.php\u0026rsquo; -o -name \u0026lsquo;.inc\u0026rsquo; -o -name \u0026lsquo;*.module\u0026rsquo; \u0026gt; cscope.files\u0026rdquo; silent! execute \u0026ldquo;!cscope -bkq -i cscope.files\u0026rdquo; if filereadable(\u0026ldquo;cscope.out\u0026rdquo;) silent! execute \u0026ldquo;cs add cscope.out\u0026rdquo; endif silent! execute \u0026ldquo;!ctags -R \u0026ndash;langmap=php:.engine.inc.module.theme.php \u0026ndash;php-kinds=cdf \u0026ndash;languages=php \u0026quot; endif endfunction\n\u0026ldquo;设置c cscope.out function! SET_CSAD() if(executable(\u0026lsquo;cscope\u0026rsquo;) \u0026amp;\u0026amp; has(\u0026ldquo;cscope\u0026rdquo;) ) silent! execute \u0026ldquo;!find . -name \u0026lsquo;.h\u0026rsquo; -o -name \u0026lsquo;.c\u0026rsquo; -o -name \u0026lsquo;*.cpp\u0026rsquo; \u0026gt; cscope.files\u0026rdquo; silent! execute \u0026ldquo;!cscope -bkq -i cscope.files\u0026rdquo; if filereadable(\u0026ldquo;cscope.out\u0026rdquo;) silent! execute \u0026ldquo;cs add cscope.out\u0026rdquo; endif silent! execute \u0026ldquo;!ctags -R \u0026ndash;c-kinds=+p \u0026ndash;c++-kinds=+p \u0026ndash;fields=+iaS \u0026ndash;extra=+q .\u0026rdquo; endif endfunction\nfunction! s:SET_CSC() let dir = expand(\u0026rdquo;%:p:h\u0026rdquo;) \u0026ldquo;获得源文件路径 \u0026ldquo;在路径上递归向上查找tags文件 while dir!=\u0026rdquo;\u0026rdquo; if findfile(\u0026ldquo;cscope.out\u0026rdquo;,dir ) !=\u0026rdquo;\u0026rdquo; \u0026ldquo;找到了就加入到tags if 0 == cscope_connection(1, \u0026ldquo;cscope.out\u0026rdquo;, dir) execute \u0026ldquo;cs add \u0026ldquo;.dir.\u0026quot;/cscope.out \u0026ldquo;.dir endif return endif \u0026ldquo;得到上级路径 let dir=GET_UP_PATH(dir) endwhile endfunction\nautocmd BufEnter * call s:SET_CSC() autocmd BufEnter * call s:SET_TAGS() \u0026ldquo;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; set laststatus=2 \u0026quot; 显示状态栏 (默认值为 1, 无法显示状态栏)\nnmap :bnext nmap :bprevious nmap :w!\nnmap 1 :set filetype=xhtml nmap 2 :set filetype=css nmap 3 :set filetype=javascript nmap 4 :set filetype=php nmap 5 :set filetype=default\nnmap hl MarkSet nmap hh MarkClear nmap hr MarkRegex vmap hl MarkSet vmap hh MarkClear vmap hr MarkRegex\nlet g:miniBufExplMapWindowNavVim = 1\nlet g:miniBufExplMapWindowNavArrows = 1\nlet g:miniBufExplMapCTabSwitchBufs = 1\nlet g:miniBufExplModSelTarget = 1\nlet g:miniBufExplMoreThanOne=0\nset mouse=a\nset noswf\nlet g:winManagerWindowLayout=\u0026ldquo;FileExplorer|TagList\u0026rdquo;\nlet Tlist_File_Fold_Auto_Close=1\n\u0026ldquo;当文件在外部被修改，自动更新该文件 set autoread\n\u0026ldquo;设置历史记录步数 set history=400\n\u0026ldquo;快速退出（保存）为, map :set mouse=v map :set mouse=a\n\u0026ldquo;开启语法 syntax enable syntax on\n\u0026ldquo;头文件与实现文件转换 map :A \u0026ldquo;设置字体\n\u0026ldquo;设置配色 colorscheme candycode\nset completeopt=menu\nset t_Co=256\n\u0026ldquo;高亮显示当前行 set cursorline hi cursorline guibg=#222222 hi CursorColumn guibg=#333333\n\u0026ldquo;tag set tags=tags;\n\u0026quot;\u0026rdquo;\u0026rdquo;\u0026rdquo;\u0026rdquo;\u0026rdquo;\u0026rdquo;\u0026rdquo;\u0026rdquo;\u0026rdquo;\u0026rdquo;\u0026rdquo;\u0026rdquo;\u0026rdquo;\u0026rdquo;\u0026rdquo;\u0026rdquo;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot; \u0026quot; =\u0026gt; 缩进 \u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot; \u0026ldquo;自动缩进 set ai\n\u0026ldquo;智能缩进 set si\n\u0026ldquo;设置缩进的空格数为4 set autoindent\n\u0026ldquo;设置自动缩进:即每行的缩进值与上一行相等；使用 noautoindent 取消设置 set shiftwidth=4 set tabstop=4 set softtabstop=4\n\u0026ldquo;设置使用 C/C++ 语言的自动缩进方式 set cin set cindent\n\u0026ldquo;显示标尺 set ruler\n\u0026ldquo;设置命令行的高度 set cmdheight=1\n\u0026ldquo;显示行数 set number\n\u0026ldquo;显示匹配的括号([{和}]) set showmatch\n\u0026ldquo;高亮显示搜索的内容 set hlsearch\n\u0026ldquo;taglist let Tlist_Show_One_File=1 let Tlist_Exit_OnlyWindow=1\n\u0026quot;\u0026rdquo;\u0026rdquo;\u0026rdquo;\u0026rdquo;\u0026rdquo;\u0026rdquo;\u0026rdquo;\u0026rdquo;\u0026rdquo;\u0026rdquo;\u0026rdquo;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot; \u0026quot; =\u0026gt; 编码设置 \u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\n\u0026ldquo;Vim 内部使用的字符编码方式，包括 Vim 的 buffer (缓冲区)、菜单文本、 \u0026ldquo;消息文本等。用户手册上建议只在 .vimrc 中改变它的值， \u0026ldquo;事实上似乎也只有在 .vimrc 中改变它的值才有意义。 set encoding=utf-8\n\u0026ldquo;Vim 启动时会按照它所列出的字符编码方式逐一探测即将打开的文件的 \u0026ldquo;字符编码方式，并且将 fileencoding 设置为最终探测到的字符编码方式。 \u0026ldquo;因此最好将 Unicode 编码方式放到这个列表的最前面。 \u0026ldquo;set fileencodings=Unicode,utf-8,gb2312,gbk,gb18030,latin-1 \u0026ldquo;set fencs=utf-8,Unicode,gb2312,gbk,gb18030,latin-1,cp936 set fencs=utf-8,ucs-bom,shift-jis,gb18030,gbk,gb2312,cp936,latin-1,prc \u0026ldquo;set fileencodings=ucs-bom,utf8,prc\n\u0026ldquo;Vim 中当前编辑的文件的字符编码方式， \u0026ldquo;Vim 保存文件时也会将文件保存为这种字符编码方式。 set fileencoding=utf-8 \u0026ldquo;set fileencoding=prc\n\u0026quot; termencoding: Vim 所工作的终端 (或者 Windows 的 Console 窗口) \u0026quot; 的字符编码方式。这个选项对 GUI 模式的 gVim 无效， \u0026quot; 而对 Console 模式的 Vim 而言就是Windows 控制台的代码页 \u0026quot; (对于 Windows 而言)，并且通常我们不需要改变它。 \u0026quot; 下面这句只影响普通模式 (非图形界面) 下的 Vim。 \u0026ldquo;set termencoding=prc let \u0026amp;termencoding=\u0026amp;encoding\n\u0026quot; \u0026ldquo;代码折叠, 命令 za set foldmethod=syntax set foldlevel=100 \u0026ldquo;启动vim时不要自动折叠代码\n\u0026quot; \u0026ldquo;自动换行 if (has(\u0026ldquo;gui_running\u0026rdquo;)) \u0026ldquo;图形界面下的设置 \u0026quot; \u0026quot; \u0026quot; \u0026ldquo;指定不折行。如果一行太长，超过屏幕宽度，则向右边延伸到屏幕外面 set nowrap \u0026quot; \u0026ldquo;添加水平滚动条。如果你指定了不折行，那为窗口添加一个水平滚动条就非常有必要 \u0026quot; 了 set guioptions+=b \u0026quot; else \u0026ldquo;字符界面下的设置 set nowrap endif\n\u0026quot; \u0026ldquo;code_complete.vim插件：函数自动完成 map :silent %!xmllint -format % if !exists(\u0026ldquo;g:completekey\u0026rdquo;) let g:completekey = \u0026ldquo;\u0026rdquo; \u0026ldquo;hotkey endif\nmap gu map gU\nmap :cp map :cn \u0026quot; \u0026ldquo;当前目录生成tags语法文件，用于自动完成，函数提示：code_complete.vim \u0026ldquo;OmniCppComplete.vim \u0026hellip; \u0026ldquo;map :call SET_CSAD() \u0026quot; \u0026quot; \u0026ldquo;函数和变量列表 map :TlistToggle \u0026quot; \u0026quot; \u0026ldquo;文件浏览器 \u0026ldquo;map :WMToggle \u0026quot; \u0026quot; \u0026ldquo;文件树状列表 nmap :execute \u0026lsquo;NERDTreeToggle \u0026lsquo;. expand(\u0026rdquo;%:p:h\u0026rdquo;) \u0026quot; \u0026quot; \u0026ldquo;映射复制、粘贴、剪贴ctrl+c ctrl+v ctrl+x \u0026quot; map \u0026ldquo;+pa \u0026quot; map! \u0026quot;+pa map \u0026ldquo;+y map \u0026ldquo;+x \u0026quot; \u0026quot; \u0026quot; 映射全选 ctrl+a map ggVG map! ggVG \u0026quot; \u0026quot; \u0026quot; 多行缩进 map \u0026gt; map \u0026lt;\n\u0026ldquo;设置自动补齐 \u0026ldquo;filetype plugin indent on \u0026ldquo;set completeopt=longest,menu\n\u0026ldquo;if has(\u0026ldquo;autocmd\u0026rdquo;) \u0026amp;\u0026amp; exists(\u0026quot;+omnifunc\u0026rdquo;) \u0026quot; autocmd Filetype * \u0026quot; \\ if \u0026amp;omnifunc == \u0026quot;\u0026rdquo; | \u0026quot; \\ setlocal omnifunc=syntaxcomplete#Complete | \u0026quot; \\ endif \u0026ldquo;endif\n\u0026ldquo;let g:SuperTabDefaultCompletionType=\u0026quot;\u0026lt;C-]\u0026gt;\u0026rdquo;\n\u0026ldquo;let g:SuperTabRetainCompletionType=0 \u0026quot; 0 - 不记录上次的补全方式 \u0026quot; 1 - 记住上次的补全方式,直到用其他的补全命令改变它 \u0026quot; 2 - 记住上次的补全方式,直到按ESC退出插入模式为止\nmap :call TitleDet()\u0026rsquo;s map :call SET_CSAD()\u0026rsquo;s map :call SET_CSPHP()\u0026rsquo;s function AddTitle() call append(0,\u0026rdquo;/*******************************************************************************\u0026rdquo;) \u0026ldquo;call append(1,\u0026rdquo;#\u0026rdquo;) call append(1,\u0026rdquo; * Author : RKhuwq\u0026rdquo;) \u0026ldquo;call append(3,\u0026rdquo;#\u0026rdquo;) call append(2,\u0026rdquo; * Email : huwq@neusoft.com\u0026rdquo;) \u0026ldquo;call append(5,\u0026rdquo;#\u0026rdquo;) call append(3,\u0026rdquo; * Last modified : \u0026ldquo;.strftime(\u0026quot;%Y-%m-%d %H:%M\u0026rdquo;)) \u0026ldquo;call append(7,\u0026rdquo;#\u0026rdquo;) call append(4,\u0026rdquo; * Filename : \u0026ldquo;.expand(\u0026rdquo;%\u0026rdquo;)) \u0026ldquo;call append(9,\u0026rdquo;#\u0026rdquo;) call append(5,\u0026rdquo; * Description : \u0026ldquo;) \u0026ldquo;call append(11,\u0026rdquo;#\u0026rdquo;) call append(6,\u0026rdquo; * *****************************************************************************/\u0026rdquo;) echohl WarningMsg | echo \u0026ldquo;Successful in adding the copyright.\u0026rdquo; | echohl None endfunction\n\u0026ldquo;更新最近修改时间和文件名 function UpdateTitle() normal m\u0026rsquo; execute \u0026rsquo; * Last modified : /s@:.$@=strftime(\u0026rdquo;:\\t%Y-%m-%d %H:%M\u0026rdquo;)@\u0026rsquo; normal \u0026quot; normal mk execute \u0026rsquo; * Filename : /s@:.$@=\u0026rdquo;:\\t\\t\u0026rdquo;.expand(\u0026rdquo;%:t\u0026rdquo;)@\u0026rsquo; execute \u0026ldquo;noh\u0026rdquo; normal \u0026lsquo;k echohl WarningMsg | echo \u0026ldquo;Successful in updating the copy right.\u0026quot;| echohl None endfunction\nautocmd BufEnter :/ * Last modified : /s@:.*$@=strftime(\u0026rdquo; : %Y-%m-%d %H:%M\u0026rdquo;)@\n\u0026ldquo;判断第四行行代码里面，是否有Last modified这个单词， \u0026ldquo;如果没有的话，代表没有添加过作者信息，需要新添加； \u0026ldquo;如果有的话，那么只需要更新即可 function TitleDet() let line = getline(4) if line =~ \u0026lsquo;\\s*\\sLast\\smodified\\s:\\s\\S*\u0026rsquo; :/ * Last modified : /s@:.*$@=strftime(\u0026rdquo;: %Y-%m-%d %H:%M\u0026rdquo;)@ return endif call AddTitle() endfunction\n\u0026ldquo;自动补全 set completeopt=menu,menuone let OmniCpp_MayCompleteDot = 1 \u0026quot; autocomplete with . let OmniCpp_MayCompleteArrow = 1 \u0026quot; autocomplete with -\u0026gt; let OmniCpp_MayCompleteScope = 1 \u0026quot; autocomplete with :: let OmniCpp_SelectFirstItem = 2 \u0026quot; select first item (but don\u0026rsquo;t insert) let OmniCpp_NamespaceSearch = 2 \u0026quot; search namespaces in this and included files let OmniCpp_ShowPrototypeInAbbr = 1 \u0026quot; show function prototype in popup window let OmniCpp_GlobalScopeSearch=1 let OmniCpp_DisplayMode=1 let OmniCpp_DefaultNamespaces=[\u0026ldquo;std\u0026rdquo;]\n\u0026quot; ~/.vimrc (configuration file for vim only) \u0026quot; skeletons \u0026ldquo;autocmd BufNewFile\t*.spec\tcall SKEL_spec() \u0026quot; filetypes filetype plugin on filetype indent on \u0026quot; ~/.vimrc ends here {% endcodeblock %} 其中F2为xml排版，F3为cscope搜索上一条，F4下一条，F6当前文件函数列表，F7目录列表，F8启用鼠标，F9不使用鼠标，F12 C语言中头文件与代码文件转换\nCtrl+E注释，Ctrl+F5生成C语言ctags与cscope，Ctrl+F6生成php语言ctags与cscope\n之后下载本文的配置。复制到$HOME目录的.vim目录中。\n下载地址\n","date":"2012-12-22T00:00:00+08:00","permalink":"https://sohunjug.com/2012/12/22/%E6%88%91%E7%9A%84vim%E9%85%8D%E7%BD%AE/","title":"我的vim配置"},{"content":"如果你手中有一个xml，而这个xml显示的排版非常混乱，大家看的时候可能会很为难，其实vim也可以实现xml的排版。\n比如你的xml是这样：\n需要安装一个程序。\n如果使用的是fedora，输入 {% codeblock lang:bash %} yum install xml2 {% endcodeblock %} 如果是其他系统可能会叫xmllint\n之后可以在终端中用命令排版， {% codeblock lang:bash %} xmllint -format -recover 后边加上文件名 {% endcodeblock %} 如果vim中使用，则需要修改~/.vimrc，添加如下： {% codeblock lang:vim %} map :silent %!xmllint -format {% endcodeblock %} 效果还不错吧～ 以后就可以使用F2直接排版xml了～\n","date":"2012-12-21T00:00:00+08:00","permalink":"https://sohunjug.com/2012/12/21/vim%E7%9A%84xml%E6%8E%92%E7%89%88/","title":"Vim的xml排版"},{"content":"眨眼间半年就过去了，毕业后的日子终究没有上学时候自由，可是大家都希望毕业，有点纠结呀。\n工作的生活有点千篇一律，天天都是代码，bug，需求。不过初次步入社会，与学校中的生活还真是区别甚大。天天的生活仿佛回到了小学，每天盼着下班，周末，放假。\n不过公司到确实给了我一个学习的环境，从Tuxedo后台服务端，到webservice后台客户端，学习了好多，大公司的项目确实很锻炼人。 我也从一个linux菜鸟，过滤到了新手的地步哈。大学之后用用ubuntu，看看apt-get 没事还得用用新得力，给人一种神秘感。即使刚进公司时，我也没想到会用linux替换windows系统。\n刚开始看各种论坛说opensuse还不错，就用了2月，gnome桌面还算挺舒服，一些额外的插件基本能满足大部分人的使用。可惜本身带了好多的程序，感觉太累赘了。后来开始研究gentoo，发现了一块新大陆，编译内核确实有点难，不过主要是wpa2，虽然安装上了wpa2-support，可是就是不好用，之后又尝试了arch-linux，安装都可以，唯一缺点是内核问题，不知道为什么总是关机显示kvm：exiting hardware virtualization就卡了，找了好久也没弄明白什么问题。因为后来看了一些博客说国外的程序员很多都用fedora和ubuntu，之后也就尝试了一下kde的fedora，尝试发现kde用着确实很爽，界面美观，发现内存使用也不是很高，我的8G内存本本现在还算勉强够用吧，估计等闲余时间多了之后，我还会折腾折腾arch或者gentoo吧。哈哈～\n现在已经彻底使用linux代替了windows系统，wine qq 基本也就够用了，其他各种工具也都有，不过最喜欢的就是写shell脚本，确实好方便呀。我会陆续发表分享的。\n其实一直都想开博客，可惜总是有些事情给耽误了。不过既然末日都因故推迟了，我推迟推迟也是应该的哈～ 我会好好做下去，有些技术也可以分享分享哈。\n","date":"2012-12-21T00:00:00+08:00","permalink":"https://sohunjug.com/2012/12/21/%E6%9C%AB%E6%97%A5%E6%9D%82%E8%AE%B0/","title":"末日杂记"},{"content":"WORDPRESS博客有些主题不支持自定义菜单，只能够选择页面和所有的分页目录作为菜单，所以为了解决这一问题，找了一些资料\n在这个之前首先对wordpress的wp_nav_menu() 函数应该了解：\n使用方法如下：\n{% codeblock lang:php %} wp_nav_menu( array( \u0026rsquo;theme_location\u0026rsquo; =\u0026gt; \u0026rsquo;\u0026rsquo; //指定显示的导航名，如果没有设置，则显示第一个 \u0026lsquo;menu\u0026rsquo; =\u0026gt; \u0026lsquo;header-menu\u0026rsquo;, \u0026lsquo;container\u0026rsquo; =\u0026gt; \u0026rsquo;nav\u0026rsquo;, //最外层容器标签名 \u0026lsquo;container_class\u0026rsquo; =\u0026gt; \u0026lsquo;primary\u0026rsquo;, //最外层容器class名 \u0026lsquo;container_id\u0026rsquo; =\u0026gt; \u0026lsquo;\u0026rsquo;,//最外层容器id值 \u0026lsquo;menu_class\u0026rsquo; =\u0026gt; \u0026lsquo;sf-menu\u0026rsquo;, //ul标签class \u0026lsquo;menu_id\u0026rsquo; =\u0026gt; \u0026rsquo;topnav\u0026rsquo;,//ul标签id \u0026rsquo;echo\u0026rsquo; =\u0026gt; true,//是否打印，默认是true，如果想将导航的代码作为赋值使用，可设置为false \u0026lsquo;fallback_cb\u0026rsquo; =\u0026gt; \u0026lsquo;wp_page_menu\u0026rsquo;,//备用的导航菜单函数，用于没有在后台设置导航时调用 \u0026lsquo;before\u0026rsquo; =\u0026gt; \u0026lsquo;\u0026rsquo;,//显示在导航a标签之前 \u0026lsquo;after\u0026rsquo; =\u0026gt; \u0026lsquo;\u0026rsquo;,//显示在导航a标签之后 \u0026rsquo;link_before\u0026rsquo; =\u0026gt; \u0026lsquo;\u0026rsquo;,//显示在导航链接名之后 \u0026rsquo;link_after\u0026rsquo; =\u0026gt; \u0026lsquo;\u0026rsquo;,//显示在导航链接名之前 \u0026lsquo;items_wrap\u0026rsquo; =\u0026gt;\n\u0026lsquo;depth\u0026rsquo; =\u0026gt; 0,////显示的菜单层数，默认0，0是显示所有层\n\u0026lsquo;walker\u0026rsquo; =\u0026gt; \u0026lsquo;\u0026rsquo;// //调用一个对象定义显示导航菜单 ));\n{% endcodeblock %}\n为了能够使后台支持自定义菜单，我们需要在主题下functions.php下 加入register_nav_menus():\n{% codeblock lang:php %} if(function_exists(\u0026lsquo;register_nav_menus\u0026rsquo;)){ register_nav_menus( array( \u0026lsquo;header-menu\u0026rsquo; =\u0026gt; ( \u0026lsquo;导航自定义菜单\u0026rsquo; ), // 还可以在这里添加一些菜单 显示在其他位置 //footer-menu=\u0026gt;( \u0026lsquo;页面底部自定义菜单\u0026rsquo; ), ) ); } {% endcodeblock %}\n在添加之后，你就会发现主题位置已经支持一个菜单了\n然后找到header.php文件, 类似这样添加：\n{% codeblock lang:php %}\n{% endcodeblock %}\n好了, 大家可以自己制作属于自己的自定义菜单了~\n","date":"2012-12-19T00:00:00+08:00","permalink":"https://sohunjug.com/2012/12/19/%E8%AE%A9wordpress%E6%94%AF%E6%8C%81%E8%87%AA%E5%AE%9A%E4%B9%89%E8%8F%9C%E5%8D%95/","title":"让wordpress支持自定义菜单"}]